"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DainTunnel = void 0;
const ws_1 = __importDefault(require("ws"));
const http_1 = __importDefault(require("http"));
const events_1 = require("events");
const bs58_1 = __importDefault(require("bs58"));
const client_1 = require("@dainprotocol/service-sdk/client");
class DainTunnel extends events_1.EventEmitter {
    constructor(serverUrl, apiKey) {
        super();
        this.serverUrl = serverUrl;
        this.ws = null;
        this.tunnelUrl = null;
        this.port = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 5000;
        this.auth = new client_1.DainClientAuth({ apiKey });
        this.tunnelId = bs58_1.default.encode(this.auth.getPublicKey());
    }
    async start(port) {
        this.port = port;
        return this.connect();
    }
    async connect() {
        return new Promise((resolve, reject) => {
            this.ws = new ws_1.default(this.serverUrl);
            this.ws.on("open", async () => {
                this.reconnectAttempts = 0;
                const challenge = await this.requestChallenge();
                const signature = this.auth.signMessage(challenge);
                this.sendMessage({
                    type: "start",
                    port: this.port,
                    challenge,
                    signature,
                    tunnelId: this.tunnelId
                });
                this.emit("connected");
            });
            this.ws.on("message", (data) => {
                const message = JSON.parse(data);
                this.handleMessage(message, resolve);
            });
            this.ws.on("close", () => {
                this.emit("disconnected");
                this.attemptReconnect();
            });
            this.ws.on("error", (error) => {
                this.emit("error", error);
                reject(error);
            });
            // Add a timeout to reject the promise if connection takes too long
            setTimeout(() => {
                var _a;
                if (((_a = this.ws) === null || _a === void 0 ? void 0 : _a.readyState) !== ws_1.default.OPEN) {
                    reject(new Error("Connection timeout"));
                }
            }, 5000);
        });
    }
    async requestChallenge() {
        return new Promise((resolve, reject) => {
            if (!this.ws) {
                reject(new Error("WebSocket is not connected"));
                return;
            }
            this.ws.send(JSON.stringify({ type: "challenge_request" }));
            const challengeHandler = (message) => {
                const data = JSON.parse(message);
                if (data.type === "challenge") {
                    if (this.ws) {
                        this.ws.removeListener("message", challengeHandler);
                    }
                    resolve(data.challenge);
                }
            };
            this.ws.on("message", challengeHandler);
            // Add a timeout for the challenge request
            setTimeout(() => {
                if (this.ws) {
                    this.ws.removeListener("message", challengeHandler);
                }
                reject(new Error("Challenge request timeout"));
            }, 5000);
        });
    }
    handleMessage(message, resolve) {
        switch (message.type) {
            case "tunnelUrl":
                this.tunnelUrl = message.url;
                resolve(this.tunnelUrl);
                this.emit("tunnel_created", this.tunnelUrl);
                break;
            case "request":
                this.handleRequest(message);
                break;
        }
    }
    async handleRequest(request) {
        try {
            const response = await this.forwardRequest(request);
            this.sendMessage(response);
            this.emit("request_handled", { request, response });
        }
        catch (error) {
            this.emit("request_error", { request, error });
        }
    }
    forwardRequest(request) {
        return new Promise((resolve, reject) => {
            const options = {
                hostname: 'localhost',
                port: this.port,
                path: request.path,
                method: request.method,
                headers: request.headers,
            };
            const req = http_1.default.request(options, (res) => {
                let body = Buffer.from([]);
                res.on('data', (chunk) => {
                    body = Buffer.concat([body, chunk]);
                });
                res.on('end', () => {
                    const headers = { ...res.headers };
                    delete headers['transfer-encoding'];
                    delete headers['content-length'];
                    resolve({
                        type: 'response',
                        requestId: request.id,
                        status: res.statusCode,
                        headers,
                        body: body.toString('base64'),
                    });
                });
            });
            req.on('error', reject);
            if (request.body && request.method !== 'GET') {
                req.write(Buffer.from(request.body, 'base64'));
            }
            req.end();
        });
    }
    sendMessage(message) {
        if (this.ws && this.ws.readyState === ws_1.default.OPEN) {
            this.ws.send(JSON.stringify(message));
        }
    }
    attemptReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            setTimeout(() => this.connect(), this.reconnectDelay);
        }
        else {
            this.emit("max_reconnect_attempts");
        }
    }
    async stop() {
        return new Promise((resolve) => {
            if (this.ws) {
                this.ws.close();
                this.ws = null;
            }
            resolve();
        });
    }
}
exports.DainTunnel = DainTunnel;
exports.default = {
    createTunnel: (serverUrl, apiKey) => new DainTunnel(serverUrl, apiKey),
};
