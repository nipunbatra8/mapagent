"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const http_1 = __importDefault(require("http"));
const ws_1 = __importDefault(require("ws"));
const uuid_1 = require("uuid");
const body_parser_1 = __importDefault(require("body-parser"));
const cors_1 = __importDefault(require("cors"));
const client_1 = require("@dainprotocol/service-sdk/client");
const bs58_1 = __importDefault(require("bs58"));
class DainTunnelServer {
    constructor(hostname, port) {
        this.hostname = hostname;
        this.port = port;
        this.tunnels = new Map();
        this.pendingRequests = new Map();
        this.challenges = new Map();
        this.app = (0, express_1.default)();
        this.server = http_1.default.createServer(this.app);
        this.wss = new ws_1.default.Server({ server: this.server });
        // Use cors middleware
        this.app.use((0, cors_1.default)());
        // Update CORS middleware
        this.app.use((req, res, next) => {
            res.header("Access-Control-Allow-Origin", "*");
            res.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, PATCH, OPTIONS");
            res.header("Access-Control-Allow-Headers", 'X-DAIN-SIGNATURE, X-DAIN-SMART-ACCOUNT-PDA, X-DAIN-AGENT-ID, X-DAIN-ORG-ID, X-DAIN-ADDRESS, X-DAIN-TIMESTAMP, Content-Type, Authorization, Accept, Origin, X-Requested-With');
            if (req.method === "OPTIONS") {
                return res.sendStatus(200);
            }
            next();
        });
        // Add body-parser middleware
        this.app.use(body_parser_1.default.raw({ type: "*/*", limit: "100mb" }));
        this.setupExpressRoutes();
        this.setupWebSocketServer();
    }
    setupExpressRoutes() {
        this.app.use("/:tunnelId", this.handleHttpRequest.bind(this));
    }
    setupWebSocketServer() {
        this.wss.on("connection", (ws) => {
            console.log("New WebSocket connection");
            ws.on("message", (message) => {
                try {
                    const data = JSON.parse(message);
                    console.log(`Received WebSocket message: ${data.type}`);
                    if (data.type === "challenge_request") {
                        this.handleChallengeRequest(ws);
                    }
                    else if (data.type === "start") {
                        this.handleStartMessage(ws, data);
                    }
                    else if (data.type === "response") {
                        this.handleResponseMessage(data);
                    }
                }
                catch (error) {
                    console.error("Error processing message:", error);
                    ws.close(1008, "Invalid message");
                }
            });
            ws.on("close", () => {
                console.log("WebSocket connection closed");
                this.removeTunnel(ws);
            });
            ws.on("error", (error) => {
                console.error("WebSocket error:", error);
            });
        });
    }
    handleChallengeRequest(ws) {
        const challenge = (0, uuid_1.v4)();
        const challengeObj = { ws, challenge };
        this.challenges.set(challenge, challengeObj);
        ws.send(JSON.stringify({ type: "challenge", challenge }));
    }
    handleStartMessage(ws, data) {
        const { challenge, signature, tunnelId } = data;
        const challengeObj = this.challenges.get(challenge);
        if (!challengeObj || challengeObj.ws !== ws) {
            ws.close(1008, "Invalid challenge");
            return;
        }
        this.challenges.delete(challenge);
        const publicKey = bs58_1.default.decode(tunnelId);
        if (!client_1.DainClientAuth.verifyMessage(challenge, signature, publicKey)) {
            ws.close(1008, "Invalid signature");
            return;
        }
        this.tunnels.set(tunnelId, { id: tunnelId, ws });
        console.log(`Tunnel added: ${tunnelId}`);
        console.log(`Current tunnels: ${Array.from(this.tunnels.keys()).join(', ')}`);
        // Add a periodic check to ensure the tunnel is still in the map
        const intervalId = setInterval(() => {
            if (this.tunnels.has(tunnelId)) {
                console.log(`Tunnel ${tunnelId} still active`);
            }
            else {
                console.log(`Tunnel ${tunnelId} not found in periodic check`);
                clearInterval(intervalId);
            }
        }, 5000); // Check every 5 seconds
        ws.on("close", () => {
            clearInterval(intervalId);
        });
        let tunnelUrl = `${this.hostname}`;
        if (process.env.SKIP_PORT !== "true") {
            tunnelUrl += `:${this.port}`;
        }
        tunnelUrl += `/${tunnelId}`;
        ws.send(JSON.stringify({ type: "tunnelUrl", url: tunnelUrl }));
        console.log(`New tunnel created: ${tunnelUrl}`);
    }
    handleResponseMessage(data) {
        const pendingRequest = this.pendingRequests.get(data.requestId);
        if (pendingRequest) {
            const { res, startTime } = pendingRequest;
            const endTime = Date.now();
            const headers = { ...data.headers };
            delete headers["transfer-encoding"];
            delete headers["content-length"];
            const bodyBuffer = Buffer.from(data.body, "base64");
            res
                .status(data.status)
                .set(headers)
                .set("Content-Length", bodyBuffer.length.toString())
                .send(bodyBuffer);
            console.log(`Request handled: ${data.requestId}, Duration: ${endTime - startTime}ms`);
            this.pendingRequests.delete(data.requestId);
        }
    }
    async handleHttpRequest(req, res) {
        const tunnelId = req.params.tunnelId;
        let tunnel;
        let retries = 3;
        while (retries > 0 && !tunnel) {
            tunnel = this.tunnels.get(tunnelId);
            if (!tunnel) {
                console.log(`Tunnel not found: ${tunnelId}, retrying... (${retries} attempts left)`);
                console.log(`Current tunnels: ${Array.from(this.tunnels.keys()).join(', ')}`);
                await new Promise(resolve => setTimeout(resolve, 100)); // Wait 100ms before retrying
                retries--;
            }
        }
        if (!tunnel) {
            console.log(`Tunnel not found after retries: ${tunnelId}`);
            return res.status(404).send("Tunnel not found");
        }
        const requestId = (0, uuid_1.v4)();
        const startTime = Date.now();
        this.pendingRequests.set(requestId, { res, startTime });
        const requestMessage = {
            type: "request",
            id: requestId,
            method: req.method,
            path: req.url,
            headers: req.headers,
            body: req.method !== "GET" && req.body
                ? req.body.toString("base64")
                : undefined,
        };
        tunnel.ws.send(JSON.stringify(requestMessage));
        console.log(`Request forwarded: ${requestId}, Method: ${req.method}, Path: ${req.url}`);
    }
    removeTunnel(ws) {
        let removedTunnelId;
        for (const [id, tunnel] of this.tunnels.entries()) {
            if (tunnel.ws === ws) {
                this.tunnels.delete(id);
                removedTunnelId = id;
                console.log(`Tunnel removed: ${id}`);
                break;
            }
        }
        if (removedTunnelId) {
            console.log(`Tunnel ${removedTunnelId} removed. Current tunnels: ${Array.from(this.tunnels.keys()).join(', ')}`);
        }
        else {
            console.log(`No tunnel found to remove for the closed WebSocket connection`);
        }
        // Also remove any pending challenges for this WebSocket
        for (const [challenge, challengeObj] of this.challenges.entries()) {
            if (challengeObj.ws === ws) {
                this.challenges.delete(challenge);
                break;
            }
        }
    }
    async start() {
        return new Promise((resolve) => {
            this.server.listen(this.port, () => {
                console.log(`DainTunnel Server is running on ${this.hostname}:${this.port}`);
                resolve();
            });
        });
    }
    async stop() {
        return new Promise((resolve) => {
            this.wss.close(() => {
                this.server.close(() => {
                    resolve();
                });
            });
        });
    }
}
exports.default = DainTunnelServer;
