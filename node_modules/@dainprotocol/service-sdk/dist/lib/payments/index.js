"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDAINServicePayments = exports.DAINServicePayments = void 0;
const tslib_1 = require("tslib");
const service_1 = require("../../service/service");
const web3_js_1 = require("@solana/web3.js");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
const stripe_1 = tslib_1.__importDefault(require("stripe"));
class DAINServicePayments {
    keypair;
    smartAccountAddress;
    stripe;
    stripePublishableKey;
    constructor(config) {
        if (typeof config.keypairOrApiKey === "string") {
            const identity = (0, service_1.parseApiKey)(config.keypairOrApiKey);
            this.keypair = web3_js_1.Keypair.fromSecretKey(bs58_1.default.decode(identity.privateKey));
            this.smartAccountAddress = new web3_js_1.PublicKey(identity.agentId);
        }
        else {
            this.keypair = config.keypairOrApiKey;
            this.smartAccountAddress = config.smartAccountAddress;
        }
        if (config.stripeSecretKey) {
            this.stripe = new stripe_1.default(config.stripeSecretKey);
            this.stripePublishableKey = config.stripePublishableKey;
        }
    }
    async createPaymentIntent(params) {
        if (params.paymentMethod === "crypto") {
            const paymentIntentAddress = web3_js_1.Keypair.generate().publicKey.toBase58();
            return {
                paymentIntentAddress,
                amount: params.amount,
                description: params.description,
                paymentMethod: "crypto"
            };
        }
        else {
            if (!this.stripe) {
                throw new Error("Stripe not configured - please provide stripe secret key in constructor");
            }
            const paymentIntent = await this.stripe.paymentIntents.create({
                amount: params.amount,
                currency: 'usd',
                description: params.description,
                automatic_payment_methods: {
                    enabled: true,
                },
            });
            return {
                publishableKey: this.stripePublishableKey || '',
                clientSecret: paymentIntent.client_secret || '',
                intentId: paymentIntent.id,
                amount: params.amount,
                description: params.description,
                paymentMethod: "stripe"
            };
        }
    }
    async checkPaid(params) {
        if (params.paymentMethod === "crypto") {
            // TODO: Implement crypto payment verification
            return true;
        }
        else {
            if (!this.stripe) {
                throw new Error("Stripe not configured - please provide stripe secret key in constructor");
            }
            const paymentIntent = await this.stripe.paymentIntents.retrieve(params.intentId);
            return paymentIntent.status === 'succeeded';
        }
    }
    static async pay(params) {
        if (params.paymentMethod === "crypto") {
            // TODO: Implement crypto payment processing
            return true;
        }
        else {
            // Client-side payment is handled by Stripe.js
            // This method shouldn't be needed for Stripe integration
            return true;
        }
    }
}
exports.DAINServicePayments = DAINServicePayments;
const createDAINServicePayments = (config) => {
    return new DAINServicePayments(config);
};
exports.createDAINServicePayments = createDAINServicePayments;
//# sourceMappingURL=index.js.map