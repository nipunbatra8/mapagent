"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelegramOAuth = void 0;
const tslib_1 = require("tslib");
const telegram_1 = require("telegram");
const sessions_1 = require("telegram/sessions");
const crypto = tslib_1.__importStar(require("crypto"));
const ws_1 = tslib_1.__importDefault(require("ws"));
class TelegramOAuth {
    config;
    wss;
    redis;
    baseUrl;
    constructor(config) {
        this.config = config;
        this.redis = config.redis;
        this.baseUrl = config.baseUrl;
        this.wss = new ws_1.default.Server({ noServer: true });
        this.setupWebSocketServer();
    }
    static generateClientId(appId, appHash) {
        const hash = crypto
            .createHash("sha256")
            .update(`${appId}:${appHash}`)
            .digest("hex");
        return `tg${hash.substring(0, 16)}`;
    }
    static generateClientSecret(appId, appHash) {
        const hash = crypto
            .createHash("sha256")
            .update(`${appHash}:${appId}:secret`)
            .digest("hex");
        return hash;
    }
    async validateClient(clientId, clientSecret) {
        const expectedClientId = TelegramOAuth.generateClientId(this.config.apiId, this.config.apiHash);
        if (clientId !== expectedClientId)
            return false;
        if (clientSecret) {
            const expectedSecret = TelegramOAuth.generateClientSecret(this.config.apiId, this.config.apiHash);
            return clientSecret === expectedSecret;
        }
        return true;
    }
    async getSession(sessionId) {
        const data = await this.redis.get(`session:${sessionId}`);
        return data ? JSON.parse(data) : null;
    }
    async setSession(sessionId, session) {
        // Create a clean copy of the session without circular references
        const cleanSession = {
            ...session,
            wsConnection: undefined, // Don't store WebSocket connection
            telegramClient: undefined, // Don't store TelegramClient
            currentPromiseResolve: undefined, // Don't store promise resolver
        };
        await this.redis.set(`session:${sessionId}`, JSON.stringify(cleanSession), "EX", 1800 // 30 minutes expiry
        );
    }
    async getToken(code) {
        return await this.redis.get(`token:${code}`);
    }
    async setToken(code, sessionString) {
        await this.redis.set(`token:${code}`, sessionString, "EX", 3600 // 1 hour expiry
        );
    }
    async deleteToken(code) {
        await this.redis.del(`token:${code}`);
    }
    setupWebSocketServer() {
        this.wss.on("connection", async (ws, req) => {
            const url = new URL(req.url, `ws://${req.headers.host}`);
            const sessionId = url.searchParams.get("session");
            if (!sessionId) {
                ws.close();
                return;
            }
            const session = await this.getSession(sessionId);
            if (!session) {
                ws.close();
                return;
            }
            session.wsConnection = ws;
            // Store the session in memory for this connection
            let currentSession = session;
            ws.on("message", async (message) => {
                try {
                    const data = JSON.parse(message.toString());
                    if (data.type === "input" && currentSession.currentPromiseResolve) {
                        // Use the in-memory session instead of fetching from Redis
                        currentSession.currentPromiseResolve(data.value);
                        currentSession.currentPromiseResolve = undefined;
                    }
                }
                catch (error) {
                    ws.send(JSON.stringify({
                        type: "error",
                        message: error.message,
                    }));
                }
            });
            try {
                const stringSession = new sessions_1.StringSession("");
                const client = new telegram_1.TelegramClient(stringSession, this.config.apiId, this.config.apiHash, {
                    connectionRetries: 5,
                });
                currentSession.telegramClient = client;
                await client.connect();
                await client.start({
                    phoneNumber: async () => {
                        currentSession.status = "awaiting_phone";
                        await this.setSession(sessionId, currentSession);
                        return await this.promptUser(currentSession, "Please enter your phone number:");
                    },
                    password: async () => {
                        currentSession.status = "awaiting_password";
                        await this.setSession(sessionId, currentSession);
                        return await this.promptUser(currentSession, "Please enter your 2FA password:");
                    },
                    phoneCode: async () => {
                        currentSession.status = "awaiting_code";
                        await this.setSession(sessionId, currentSession);
                        return await this.promptUser(currentSession, "Please enter the code you received:");
                    },
                    onError: (err) => {
                        ws.send(JSON.stringify({
                            type: "error",
                            message: err.message,
                        }));
                        throw err;
                    },
                });
                const sessionString = client.session.save();
                const token = crypto.randomBytes(32).toString("hex");
                await this.setToken(token, sessionString);
                currentSession.status = "completed";
                await this.setSession(sessionId, currentSession);
                ws.send(JSON.stringify({
                    type: "success",
                    redirectUri: `${currentSession.redirectUri}?code=${token}&state=${currentSession.state}`,
                }));
            }
            catch (error) {
                ws.send(JSON.stringify({
                    type: "error",
                    message: error.message,
                }));
                ws.close();
            }
        });
    }
    async promptUser(session, message) {
        return new Promise((resolve) => {
            if (session.wsConnection?.readyState === ws_1.default.OPEN) {
                session.currentPromiseResolve = resolve;
                session.wsConnection.send(JSON.stringify({
                    type: "prompt",
                    message,
                }));
            }
            else {
                resolve("");
            }
        });
    }
    connect(app, server) {
        app.get("/addons/telegram-oauth/auth.html", (c) => {
            return c.html(`
                <!DOCTYPE html>
                <html>
                    <head>
                        <title>Telegram OAuth</title>
                        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/17.0.8/css/intlTelInput.css">
                        <style>
                            body {
                                background-color: #f3f4f6;
                                height: 100vh;
                                margin: 0;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-family: system-ui, -apple-system, sans-serif;
                            }
                            .container {
                                background-color: white;
                                padding: 2rem;
                                border-radius: 0.5rem;
                                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
                                width: 24rem;
                            }
                            .logo-container {
                                display: flex;
                                flex-direction: column;
                                align-items: center;
                                margin-bottom: 1.5rem;
                            }
                            .logo {
                                width: 4rem;
                                height: 4rem;
                                margin-bottom: 1rem;
                            }
                            .title {
                                font-size: 1.5rem;
                                font-weight: bold;
                                color: #1f2937;
                                margin-bottom: 0.5rem;
                            }
                            .subtitle {
                                font-size: 1rem;
                                color: #6b7280;
                                text-align: center;
                                margin-bottom: 1.5rem;
                            }
                            .input {
                                width: 100%;
                                padding: 0.75rem 1rem;
                                border: 1px solid #e5e7eb;
                                border-radius: 0.5rem;
                                margin-bottom: 1rem;
                                box-sizing: border-box;
                                font-size: 1rem;
                            }
                            .button {
                                width: 100%;
                                padding: 0.75rem 1rem;
                                background-color: #3b82f6;
                                color: white;
                                border: none;
                                border-radius: 0.5rem;
                                cursor: pointer;
                                transition: background-color 150ms;
                                font-size: 1rem;
                                font-weight: 500;
                            }
                            .button:hover {
                                background-color: #2563eb;
                            }
                            .status {
                                margin-top: 1rem;
                                text-align: center;
                                font-size: 0.875rem;
                                color: #4b5563;
                            }
                            .step {
                                display: none;
                            }
                            .step.active {
                                display: block;
                            }
                            .error {
                                color: #dc2626;
                                margin-top: 0.5rem;
                                text-align: center;
                                font-size: 0.875rem;
                            }
                            .loading {
                                display: inline-block;
                                width: 1rem;
                                height: 1rem;
                                border: 2px solid #e5e7eb;
                                border-radius: 50%;
                                border-top-color: #3b82f6;
                                animation: spin 1s linear infinite;
                                margin-right: 0.5rem;
                            }
                            @keyframes spin {
                                to { transform: rotate(360deg); }
                            }
                            .iti {
                                width: 100%;
                                margin-bottom: 1rem;
                            }
                            .iti__flag {
                                background-image: url("https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/17.0.8/img/flags.png");
                            }
                            @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
                                .iti__flag {
                                    background-image: url("https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/17.0.8/img/flags@2x.png");
                                }
                            }
                        </style>
                    </head>
                    <body>
                        <div class="container">
                            <div class="logo-container">
                                <img src="https://telegram.org/img/t_logo.svg" alt="Telegram Logo" class="logo">
                                <h2 class="title">Telegram Authentication</h2>
                            </div>
        
                            <div id="connecting-step" class="step active">
                                <p class="subtitle">Connecting to Telegram...</p>
                                <div class="status">
                                    <span class="loading"></span>
                                    Establishing secure connection
                                </div>
                            </div>
        
                            <div id="phone-step" class="step">
                                <p class="subtitle">Enter your phone number to continue</p>
                                <input type="tel" id="phone-input" class="input" placeholder="Enter phone number">
                                <button id="phone-submit" class="button">Continue</button>
                                <div id="phone-error" class="error"></div>
                            </div>
        
                            <div id="code-step" class="step">
                                <p class="subtitle">Enter the code sent to your device</p>
                                <input type="text" id="code-input" class="input" placeholder="Enter code">
                                <button id="code-submit" class="button">Verify Code</button>
                                <div id="code-error" class="error"></div>
                            </div>
        
                            <div id="password-step" class="step">
                                <p class="subtitle">Enter your 2FA password</p>
                                <input type="password" id="password-input" class="input" placeholder="Enter password">
                                <button id="password-submit" class="button">Sign In</button>
                                <div id="password-error" class="error"></div>
                            </div>
        
                            <div id="success-step" class="step">
                                <p class="subtitle">Authentication successful!</p>
                                <div class="status">Redirecting you...</div>
                            </div>
                        </div>
        
                        <script src="https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/17.0.8/js/intlTelInput.min.js"></script>
                        <script>
                            const sessionId = new URLSearchParams(window.location.search).get('session');
                            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                            const wsPath = window.location.pathname.replace('/auth.html', '/ws');
                            const wsUrl = wsProtocol + '//' + window.location.host + wsPath + '?session=' + sessionId;
                            console.log('Connecting to WebSocket:', wsUrl);
                            const ws = new WebSocket(wsUrl);
        
                            ws.onerror = (error) => {
                                console.error('WebSocket error:', error);
                            };
        
                            ws.onopen = () => {
                                console.log('WebSocket connected');
                            };
        
                            const steps = ['connecting-step', 'phone-step', 'code-step', 'password-step', 'success-step'];
                            let currentInput = null;
                            let currentSubmit = null;
                            let currentError = null;
        
                            function showStep(stepId) {
                                steps.forEach(step => {
                                    document.getElementById(step).classList.remove('active');
                                });
                                document.getElementById(stepId).classList.add('active');
                                
                                // Set current input and submit elements
                                currentInput = document.getElementById(stepId.replace('-step', '-input'));
                                currentSubmit = document.getElementById(stepId.replace('-step', '-submit'));
                                currentError = document.getElementById(stepId.replace('-step', '-error'));
        
                                if (currentInput) {
                                    currentInput.focus();
                                }
                            }
        
                            function handleSubmit() {
                                if (currentInput && ws) {
                                    let inputValue = currentInput.value.trim();
                                    
                                    // If this is the phone input, format it properly
                                    if (currentInput.id === 'phone-input') {
                                        if (!iti.isValidNumber()) {
                                            currentError.textContent = 'Please enter a valid phone number';
                                            return;
                                        }
                                        inputValue = iti.getNumber(); // This will return the full number with country code
                                    }
        
                                    if (inputValue) {
                                        currentError.textContent = '';
                                        ws.send(JSON.stringify({ type: 'input', value: inputValue }));
                                        currentInput.value = '';
                                        currentSubmit.disabled = true;
                                        currentSubmit.innerHTML = '<span class="loading"></span>Processing...';
                                    }
                                }
                            }
        
                            ws.onmessage = (event) => {
                                const data = JSON.parse(event.data);
                                console.log('Received:', data);
                                
                                if (data.type === 'error') {
                                    if (currentError) {
                                        currentError.textContent = data.message;
                                        currentSubmit.disabled = false;
                                        currentSubmit.textContent = currentSubmit.originalText || 'Submit';
                                    }
                                } else if (data.type === 'success') {
                                    showStep('success-step');
                                    setTimeout(() => {
                                        window.location.href = data.redirectUri;
                                    }, 1500);
                                } else if (data.type === 'prompt') {
                                    if (data.message.includes('phone')) {
                                        showStep('phone-step');
                                    } else if (data.message.includes('code')) {
                                        showStep('code-step');
                                    } else if (data.message.includes('password')) {
                                        showStep('password-step');
                                    }
                                }
                            };
        
                            // Add event listeners for all submit buttons
                            steps.forEach(stepId => {
                                const submitBtn = document.getElementById(stepId.replace('-step', '-submit'));
                                const input = document.getElementById(stepId.replace('-step', '-input'));
                                
                                if (submitBtn && input) {
                                    submitBtn.originalText = submitBtn.textContent;
                                    
                                    submitBtn.addEventListener('click', handleSubmit);
                                    input.addEventListener('keypress', (e) => {
                                        if (e.key === 'Enter') handleSubmit();
                                    });
                                }
                            });
        
                            // Initialize the phone input
                            const phoneInput = document.getElementById('phone-input');
                            const iti = window.intlTelInput(phoneInput, {
                                utilsScript: "https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/17.0.8/js/utils.js",
                                separateDialCode: true,
                                initialCountry: "auto",
                                geoIpLookup: function(callback) {
                                    fetch("https://ipapi.co/json")
                                        .then(res => res.json())
                                        .then(data => callback(data.country_code))
                                        .catch(() => callback("us"));
                                },
                            });
                        </script>
                    </body>
                </html>
            `);
        });
        app.get("/addons/telegram-oauth/oauth/authorize", async (c) => {
            const { client_id, redirect_uri, state } = c.req.query();
            if (!client_id || !redirect_uri) {
                return c.json({ error: "Missing required parameters" }, 400);
            }
            // Validate client_id
            const isValidClient = await this.validateClient(client_id);
            if (!isValidClient) {
                return c.json({ error: "Invalid client_id" }, 401);
            }
            const sessionId = crypto.randomBytes(16).toString("hex");
            const session = {
                id: sessionId,
                clientId: client_id,
                redirectUri: redirect_uri,
                state: state || "",
                status: "pending",
                createdAt: new Date(),
                expiresAt: new Date(Date.now() + 30 * 60 * 1000),
            };
            await this.setSession(sessionId, session);
            return c.redirect(this.baseUrl + `/addons/telegram-oauth/auth.html?session=${sessionId}`);
        });
        app.post("/addons/telegram-oauth/oauth/token", async (c) => {
            const body = await c.req.parseBody();
            const { code, client_id, client_secret, grant_type, redirect_uri } = body;
            if (!code || !client_id || !client_secret || !grant_type || !redirect_uri) {
                return c.json({ error: "Missing required parameters" }, 400);
            }
            if (grant_type !== "authorization_code") {
                return c.json({ error: "Invalid grant type" }, 400);
            }
            // Validate client credentials
            const isValidClient = await this.validateClient(client_id, client_secret);
            if (!isValidClient) {
                return c.json({ error: "Invalid client credentials" }, 401);
            }
            const sessionString = await this.getToken(code);
            if (!sessionString) {
                return c.json({ error: "Invalid code" }, 400);
            }
            await this.deleteToken(code);
            return c.json({
                access_token: sessionString,
                token_type: "Bearer",
                expires_in: 3600,
                scope: "", // Telegram doesn't use scopes
                refresh_token: null // Telegram sessions don't need refresh
            });
        });
        app.get("/addons/telegram-oauth/ws", (c) => {
            // This route won't actually handle the WebSocket connection
            // It's just here to ensure the path exists
            return c.body(null);
        });
        // Setup WebSocket upgrade handling
        server.on("upgrade", (req, socket, head) => {
            const url = new URL(req.url, `http://${req.headers.host}`);
            // Only handle upgrade for our specific WebSocket path
            if (url.pathname.endsWith('/addons/telegram-oauth/ws')) {
                this.wss.handleUpgrade(req, socket, head, (ws) => {
                    this.wss.emit("connection", ws, req);
                });
            }
        });
    }
    // Get client credentials - useful for applications
    getClientCredentials() {
        return {
            clientId: TelegramOAuth.generateClientId(this.config.apiId, this.config.apiHash),
            clientSecret: TelegramOAuth.generateClientSecret(this.config.apiId, this.config.apiHash),
        };
    }
    getOAuth2ProviderConfig(options) {
        const clientCredentials = this.getClientCredentials();
        return {
            clientId: clientCredentials.clientId,
            clientSecret: clientCredentials.clientSecret,
            authorizationUrl: `${this.baseUrl}/addons/telegram-oauth/oauth/authorize`,
            tokenUrl: `${this.baseUrl}/addons/telegram-oauth/oauth/token`,
            scopes: [], // Telegram OAuth doesn't use scopes
            reason: options?.reason || "Required to access your Telegram account",
            requiredTools: options?.requiredTools || [],
            onSuccess: options?.onSuccess,
        };
    }
}
exports.TelegramOAuth = TelegramOAuth;
//# sourceMappingURL=telegram-oauth.js.map