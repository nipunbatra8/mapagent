"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuth2Handler = void 0;
const iron_session_1 = require("iron-session");
const oauth2Store_1 = require("./oauth2Store");
const crypto_1 = require("crypto");
class OAuth2Handler {
    providers;
    privateKey;
    baseUrl;
    tokenStore;
    constructor(privateKey, baseUrl, tokenStore) {
        this.providers = new Map();
        this.privateKey = privateKey;
        this.baseUrl = baseUrl;
        this.tokenStore = tokenStore || new oauth2Store_1.InMemoryOAuth2TokenStore();
    }
    registerProvider(name, config) {
        this.providers.set(name, config);
    }
    generateCodeVerifier() {
        return (0, crypto_1.randomBytes)(32)
            .toString('base64')
            .replace(/[^a-zA-Z0-9]/g, '')
            .substring(0, 128);
    }
    generateCodeChallenge(verifier) {
        const hash = (0, crypto_1.createHash)('sha256').update(verifier).digest();
        return hash.toString('base64')
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
    }
    async generateAuthUrl(provider, agentId) {
        const providerConfig = this.providers.get(provider);
        if (!providerConfig)
            throw new Error(`Unknown provider: ${provider}`);
        const stateData = {
            agentId,
            provider,
            timestamp: Date.now(),
        };
        // Base params
        const baseParams = {
            response_type: 'code',
            client_id: providerConfig.clientId,
            redirect_uri: `${this.baseUrl}/oauth2/callback/${provider}`,
            scope: providerConfig.scopes.join(' '),
        };
        if (providerConfig.usePKCE) {
            // Generate random codeVerifier
            const codeVerifier = this.generateCodeVerifier();
            // Create the codeChallenge from codeVerifier
            const codeChallenge = this.generateCodeChallenge(codeVerifier);
            stateData.codeVerifier = codeVerifier;
            // Add PKCE fields
            Object.assign(baseParams, {
                code_challenge: codeChallenge,
                code_challenge_method: 'S256',
            });
        }
        baseParams.state = await this.encodeState(stateData);
        if (providerConfig.extraAuthParams) {
            Object.assign(baseParams, providerConfig.extraAuthParams);
        }
        // Construct the final URL
        const params = new URLSearchParams(baseParams);
        return `${providerConfig.authorizationUrl}?${params.toString()}`;
    }
    async handleCallback(code, state) {
        const stateData = await this.decodeState(state);
        const providerConfig = this.providers.get(stateData.provider);
        if (!providerConfig) {
            throw new Error("Invalid provider");
        }
        const tokens = await this.exchangeCodeForTokens(code, providerConfig, stateData.provider, stateData.codeVerifier);
        await this.tokenStore.saveTokens(stateData.agentId, stateData.provider, tokens);
        if (providerConfig.onSuccess) {
            await providerConfig.onSuccess(stateData.agentId, tokens);
        }
        return {
            agentId: stateData.agentId,
            provider: stateData.provider,
            tokens,
        };
    }
    async exchangeCodeForTokens(code, config, provider, codeVerifier) {
        const params = new URLSearchParams({
            client_id: config.clientId,
            redirect_uri: `${this.baseUrl}/oauth2/callback/${provider}`,
            code,
            grant_type: 'authorization_code',
        });
        if (config.usePKCE) {
            if (!codeVerifier) {
                throw new Error("PKCE is enabled, but the codeVerifier is missing from state.");
            }
            params.append('code_verifier', codeVerifier);
        }
        else {
            params.append('client_secret', config.clientSecret);
        }
        const headers = {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Accept': 'application/json',
        };
        if (config.usePKCE && config.useBasicAuth) {
            const basicAuth = Buffer.from(`${config.clientId}:${config.clientSecret}`).toString('base64');
            headers['Authorization'] = `Basic ${basicAuth}`;
        }
        const response = await fetch(config.tokenUrl, {
            method: 'POST',
            headers,
            body: params.toString(),
        });
        if (!response.ok) {
            const error = await response.text();
            throw new Error(`Failed to exchange code for tokens: ${error}`);
        }
        const data = await response.json();
        // If the provider specifies a responseRootKey (e.g. 'authed_user' for Telegram),
        // parse the token data from that sub-object.
        if (config.responseRootKey && data[config.responseRootKey]) {
            Object.assign(data, data[config.responseRootKey]);
        }
        return {
            accessToken: data.access_token,
            refreshToken: data.refresh_token,
            scope: data.scope,
            createdAt: Date.now()
        };
    }
    async encodeState(data) {
        return await (0, iron_session_1.sealData)(data, { password: this.privateKey });
    }
    async decodeState(state) {
        return await (0, iron_session_1.unsealData)(state, { password: this.privateKey });
    }
    async hasValidTokens(provider, agentId) {
        const providerConfig = this.providers.get(provider);
        if (!providerConfig)
            throw new Error(`Unknown provider: ${provider}`);
        return this.tokenStore.hasValidTokens(agentId, provider);
    }
    async getProviders(agentId) {
        const providers = await Promise.all(Array.from(this.providers.entries()).map(async ([name, config]) => ({
            name,
            config: {
                clientId: config.clientId,
                authorizationUrl: config.authorizationUrl,
                tokenUrl: config.tokenUrl,
                scopes: config.scopes,
                reason: config.reason,
                requiredTools: config.requiredTools
            },
            connected: await this.tokenStore.hasValidTokens(agentId, name)
        })));
        return providers;
    }
}
exports.OAuth2Handler = OAuth2Handler;
//# sourceMappingURL=oauth2.js.map