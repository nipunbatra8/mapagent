"use strict";
// File: src/service/auth.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.addressToPublicKeyBytes = addressToPublicKeyBytes;
exports.signatureToBytes = signatureToBytes;
exports.verifySignature = verifySignature;
exports.sanitizeHeaders = sanitizeHeaders;
exports.signResponse = signResponse;
exports.verifyResponse = verifyResponse;
exports.verifyRequestSignature = verifyRequestSignature;
exports.isValidSolanaAddress = isValidSolanaAddress;
const tslib_1 = require("tslib");
const ed25519_1 = require("@noble/curves/ed25519");
const sha256_1 = require("@noble/hashes/sha256");
const utils_1 = require("@noble/hashes/utils");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
function addressToPublicKeyBytes(address) {
    try {
        return bs58_1.default.decode(address);
    }
    catch (error) {
        throw new Error("Invalid Solana address format");
    }
}
function signatureToBytes(signature) {
    if (!/^[0-9a-fA-F]{128}$/.test(signature)) {
        throw new Error("Invalid signature format");
    }
    return (0, utils_1.hexToBytes)(signature);
}
function verifySignature(signature, message, address) {
    try {
        const publicKey = addressToPublicKeyBytes(address);
        const signatureBytes = signatureToBytes(signature);
        const messageHash = (0, sha256_1.sha256)(message);
        return ed25519_1.ed25519.verify(signatureBytes, messageHash, publicKey);
    }
    catch (error) {
        console.log("Signature verification error:", error);
        return false;
    }
}
function sanitizeHeaders(headers) {
    const sanitizedHeaders = {};
    for (const [key, value] of Object.entries(headers)) {
        const upperKey = key.toUpperCase();
        if ((upperKey === "CONTENT-TYPE" || upperKey.startsWith("X-")) &&
            typeof value === "string") {
            sanitizedHeaders[upperKey] = value;
        }
        else if ((upperKey === "CONTENT-TYPE" || upperKey.startsWith("X-")) &&
            Array.isArray(value) &&
            value.length > 0) {
            sanitizedHeaders[upperKey] = value.join(", "); // Convert array to comma-separated string
        }
    }
    // Sort headers alphabetically by key
    const sortedSanitizedHeaders = Object.keys(sanitizedHeaders)
        .sort()
        .reduce((acc, key) => {
        acc[key] = sanitizedHeaders[key];
        return acc;
    }, {});
    return sortedSanitizedHeaders;
}
function signResponse(privateKey, responseBody) {
    const timestamp = Date.now().toString();
    const messageHash = (0, sha256_1.sha256)((0, utils_1.concatBytes)(new TextEncoder().encode(responseBody), new TextEncoder().encode(timestamp)));
    const signature = ed25519_1.ed25519.sign(messageHash, privateKey);
    return { signature: (0, utils_1.bytesToHex)(signature), timestamp };
}
function verifyResponse(publicKey, responseBody, signature, timestamp) {
    try {
        const messageHash = (0, sha256_1.sha256)((0, utils_1.concatBytes)(new TextEncoder().encode(responseBody), new TextEncoder().encode(timestamp)));
        const signatureBytes = (0, utils_1.hexToBytes)(signature);
        return ed25519_1.ed25519.verify(signatureBytes, messageHash, publicKey);
    }
    catch (error) {
        console.error("Response verification error:", error);
        return false;
    }
}
function verifyRequestSignature(signature, method, path, headers, body, address, smartAccountPDA) {
    //TODO smartAccountPDA check
    const timestamp = headers["X-DAIN-TIMESTAMP"];
    if (!timestamp) {
        return false;
    }
    // remove x-dain-timestamp from headers
    delete headers["X-DAIN-TIMESTAMP"];
    //delete the signature from headers
    delete headers["X-DAIN-SIGNATURE"];
    const message = `${method.toUpperCase()}:${path}:${timestamp}:${body ? body : "{}"}`;
    return verifySignature(signature, message, address);
}
function isValidSolanaAddress(address) {
    try {
        addressToPublicKeyBytes(address);
        return true;
    }
    catch {
        return false;
    }
}
//# sourceMappingURL=auth.js.map