import { AgentInfo } from "./types";
export interface ProcessUpdate {
    percentage?: number;
    text: string;
    createdAt: Date;
}
export type WebhookPayloadBase = {
    processId: string;
    serviceId: string;
    agentId: string;
};
export type ProcessCreatedPayload = WebhookPayloadBase & {
    type: "process_created";
    process: {
        id: string;
        name: string;
        description: string;
        type: "one-time" | "recurring";
        agentId: string;
    };
};
export type ProcessUpdatePayload = WebhookPayloadBase & {
    type: "process_update";
    update: ProcessUpdate;
};
export type ProcessResultPayload = WebhookPayloadBase & {
    type: "process_result";
    result: ProcessResult;
    isComplete: boolean;
};
export type ProcessFailedPayload = WebhookPayloadBase & {
    type: "process_failed";
    error: string;
};
export interface HumanActionStep {
    id: string;
    processId: string;
    message: string;
    ui?: any;
    actions: {
        id: string;
        title: string;
        description?: string;
        requiresResponse?: boolean;
        callbackUrl?: string;
    }[];
    status: 'pending' | 'completed' | 'failed' | 'timeout';
    response?: {
        actionId: string;
        responseText?: string;
        timestamp: Date;
        data?: any;
    };
    createdAt: Date;
    timeoutAt?: Date;
    _metadata?: Record<string, any>;
}
export type HumanActionRequestedPayload = WebhookPayloadBase & {
    type: "human_action_requested";
    step: Omit<HumanActionStep, '_metadata'>;
};
export type HumanActionCompletedPayload = WebhookPayloadBase & {
    type: "human_action_completed";
    step: Omit<HumanActionStep, '_metadata'>;
};
export type WebhookPayload = ProcessCreatedPayload | ProcessUpdatePayload | ProcessResultPayload | ProcessFailedPayload | HumanActionRequestedPayload | HumanActionCompletedPayload;
export interface ProcessResult {
    text: string;
    data: any;
    ui?: any;
}
export interface Process {
    id: string;
    name: string;
    description: string;
    agentId: string;
    webhookUrl?: string;
    type: "one-time" | "recurring";
    status: "running" | "completed" | "failed";
    updates: ProcessUpdate[];
    results: ProcessResult[];
    agentInfo: AgentInfo;
    humanActions: HumanActionStep[];
}
export declare class MemoryProcessStore implements ProcessStoreAdapter {
    private processes;
    saveProcess(process: Process): Promise<void>;
    getProcess(processId: string): Promise<Process | null>;
    updateProcess(processId: string, updates: Partial<Process>): Promise<void>;
    getHumanAction(processId: string, stepId: string): Promise<HumanActionStep | null>;
    updateHumanAction(processId: string, stepId: string, updates: Partial<HumanActionStep>): Promise<void>;
}
export interface ProcessStoreAdapter {
    saveProcess(process: Process): Promise<void>;
    getProcess(processId: string): Promise<Process | null>;
    updateProcess(processId: string, updates: Partial<Process>): Promise<void>;
    getHumanAction(processId: string, stepId: string): Promise<HumanActionStep | null>;
    updateHumanAction(processId: string, stepId: string, updates: Partial<HumanActionStep>): Promise<void>;
}
export declare class RedisProcessStore implements ProcessStoreAdapter {
    private redis;
    private prefix;
    constructor(redisUrl?: string);
    saveProcess(process: Process): Promise<void>;
    getProcess(processId: string): Promise<Process | null>;
    updateProcess(processId: string, updates: Partial<Process>): Promise<void>;
    getHumanAction(processId: string, stepId: string): Promise<HumanActionStep | null>;
    updateHumanAction(processId: string, stepId: string, updates: Partial<HumanActionStep>): Promise<void>;
}
export declare class UpstashProcessStore implements ProcessStoreAdapter {
    private baseUrl;
    private token;
    constructor();
    private fetchRedis;
    saveProcess(process: Process): Promise<void>;
    getProcess(processId: string): Promise<Process | null>;
    updateProcess(processId: string, updates: Partial<Process>): Promise<void>;
    getHumanAction(processId: string, stepId: string): Promise<HumanActionStep | null>;
    updateHumanAction(processId: string, stepId: string, updates: Partial<HumanActionStep>): Promise<void>;
}
export declare class ProcessHandler {
    private store;
    private serviceId;
    private privateKey;
    private baseUrl?;
    private onHumanActionResponse?;
    constructor({ serviceId, privateKey, apiKey, store, baseUrl, onHumanActionResponse, }: {
        serviceId?: string;
        baseUrl?: string;
        onHumanActionResponse?: (response: {
            process: Process;
            stepId: string;
            actionId: string;
            responseText?: string;
            data?: any;
        }) => Promise<void>;
    } & ({
        privateKey: Uint8Array;
        apiKey?: never;
        serviceId?: string;
    } | {
        apiKey: string;
        privateKey?: never;
        serviceId?: never;
    }) & {
        store?: ProcessStoreAdapter;
    });
    private generateProcessId;
    private signWebhookPayload;
    createProcess(agentInfo: AgentInfo, type: "one-time" | "recurring", name?: string, description?: string): Promise<string>;
    addUpdate(processId: string, update: Omit<ProcessUpdate, "createdAt">): Promise<void>;
    addResult(processId: string, result: ProcessResult): Promise<void>;
    getProcess(processId: string): Promise<Process | null>;
    failProcess(processId: string, error: string): Promise<void>;
    getProcessStatus(processId: string, agentId: string): Promise<{
        id: string;
        status: Process["status"];
        updates: ProcessUpdate[];
        results: ProcessResult[];
        humanActions: HumanActionStep[];
    } | null>;
    requestHumanAction(processId: string, options: {
        message: string;
        ui?: any;
        actions: Array<{
            id: string;
            title: string;
            requiresResponse?: boolean;
        }>;
        metadata?: any;
        timeoutMs?: number;
    }): Promise<string>;
    checkHumanAction(processId: string, stepId: string): Promise<{
        status: 'pending' | 'completed' | 'failed' | 'timeout';
        response?: {
            actionId: string;
            responseText?: string;
            data?: any;
        };
    }>;
    waitForHumanAction(processId: string, stepId: string, timeoutMs?: number): Promise<{
        actionId: string;
        responseText?: string;
        data?: any;
    }>;
    respondToHumanAction(processId: string, stepId: string, actionId: string, responseText?: string, data?: any): Promise<void>;
}
