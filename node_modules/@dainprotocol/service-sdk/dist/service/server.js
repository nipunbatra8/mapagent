"use strict";
// File: src/service/server.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupHttpServer = setupHttpServer;
const tslib_1 = require("tslib");
const hono_1 = require("hono");
const cors_1 = require("hono/cors");
const http_exception_1 = require("hono/http-exception");
const auth_1 = require("./auth");
const schemaStructure_1 = require("../lib/schemaStructure");
const zod_to_json_schema_1 = tslib_1.__importDefault(require("zod-to-json-schema"));
const oauth2_1 = require("./oauth2");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
const processes_1 = require("./processes");
const streaming_1 = require("hono/streaming");
function setupHttpServer(config, tools, services, toolboxes, metadata, privateKey, contexts, pinnables) {
    const app = new hono_1.Hono();
    const processHandler = new processes_1.ProcessHandler({
        serviceId: "service_" + config.identity.orgId + "_" + config.identity.agentId,
        privateKey,
        store: config.processStore,
        baseUrl: config.baseUrl,
        onHumanActionResponse: config.onHumanActionResponse
    });
    app.processes = processHandler;
    // CORS middleware - apply to all routes
    app.use("*", (0, cors_1.cors)({
        origin: "*",
        allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        allowHeaders: [
            "X-DAIN-SIGNATURE",
            "X-DAIN-SMART-ACCOUNT-PDA",
            "X-DAIN-AGENT-ID",
            "X-DAIN-ORG-ID",
            "X-DAIN-ADDRESS",
            "X-DAIN-TIMESTAMP",
            "X-DAIN-WEBHOOK-URL",
            "Content-Type",
            "Authorization",
            "Accept",
            "Origin",
            "X-Requested-With",
        ],
    }));
    // Handle OPTIONS requests for CORS pre-flight
    app.options("*", (c) => {
        return c.text("Enabling CORS Pre-Flight", 204, {
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
            "Access-Control-Allow-Headers": "X-DAIN-SIGNATURE, X-DAIN-SMART-ACCOUNT-PDA, X-DAIN-AGENT-ID, X-DAIN-ORG-ID, X-DAIN-ADDRESS, X-DAIN-TIMESTAMP, Content-Type, Authorization, Accept, Origin, X-Requested-With",
            "Access-Control-Max-Age": "86400",
        });
    });
    // Middleware to sign all responses - exclude /addons
    app.use("*", async (c, next) => {
        if (c.req.path.startsWith("/addons")) {
            await next();
            return;
        }
        await next();
        const body = await c.res.clone().text();
        const { signature, timestamp } = (0, auth_1.signResponse)(privateKey, body);
        c.res.headers.set("X-DAIN-SIGNATURE", signature);
        c.res.headers.set("X-DAIN-AGENT-ID", config.identity.agentId);
        c.res.headers.set("X-DAIN-ORG-ID", config.identity.orgId);
        c.res.headers.set("X-DAIN-ADDRESS", config.identity.publicKey);
        c.res.headers.set("X-DAIN-TIMESTAMP", timestamp);
    });
    // Middleware for signature verification - exclude /addons
    app.use("*", async (c, next) => {
        // Skip auth check for OAuth callback routes and addons
        if (c.req.path.startsWith("/oauth2/callback/") || c.req.path.startsWith("/addons")) {
            await next();
            return;
        }
        const signature = c.req.header("X-DAIN-SIGNATURE");
        const address = c.req.header("X-DAIN-ADDRESS");
        const timestamp = c.req.header("X-DAIN-TIMESTAMP");
        const smartAccountPDA = c.req.header("X-DAIN-SMART-ACCOUNT-PDA");
        if (!signature || !address || !timestamp) {
            throw new http_exception_1.HTTPException(401, {
                message: "Missing authentication headers.\n\n TIP: You should not be visiting this page directly. This service URL can be connected to by a DAIN client or assistant (such as Butterfly)",
            });
        }
        const method = c.req.method;
        const path = c.req.path;
        const headers = (0, auth_1.sanitizeHeaders)(c.req.header());
        const body = await c.req.text();
        if (!(0, auth_1.verifyRequestSignature)(signature, method, path, headers, body, address, smartAccountPDA)) {
            throw new http_exception_1.HTTPException(401, { message: "Invalid signature" });
        }
        await next();
    });
    async function getAgentInfo(c) {
        const smartAccountPDA = c.req.header("X-DAIN-SMART-ACCOUNT-PDA");
        const address = c.req.header("X-DAIN-ADDRESS");
        const agentId = c.req.header("X-DAIN-AGENT-ID");
        const webhookUrl = c.req.header("X-DAIN-WEBHOOK-URL");
        return {
            agentId: agentId,
            address: address,
            smartAccountPDA: smartAccountPDA,
            id: smartAccountPDA ? `dain_id_${smartAccountPDA}` : `address_${address}`,
            webhookUrl: webhookUrl,
        };
    }
    // Setup default ping route
    app.get("/ping", (c) => c.json({ message: "pong", platform: "DAIN", version: metadata.version }));
    // Metadata endpoint
    app.get("/metadata", (c) => c.json(metadata));
    // Tools list endpoint
    app.get("/tools", (c) => {
        const toolInfo = tools.map((tool) => ({
            id: tool.id,
            name: tool.name,
            description: tool.description,
            pricing: tool.pricing,
            inputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(tool.input),
            outputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(tool.output),
            suggestConfirmation: tool.suggestConfirmation,
        }));
        return c.json(toolInfo);
    });
    app.get("/contexts", (c) => {
        const contextInfo = contexts.map((context) => ({
            id: context.id,
            name: context.name,
            description: context.description,
        }));
        return c.json(contextInfo);
    });
    app.get("/contexts/:contextId", async (c) => {
        const context = contexts.find((context) => context.id === c.req.param("contextId"));
        if (context) {
            const agentInfo = await getAgentInfo(c);
            return c.json({
                id: context.id,
                name: context.name,
                description: context.description,
                data: await context.getContextData(agentInfo),
            });
        }
        else {
            throw new http_exception_1.HTTPException(404, { message: "Context not found" });
        }
    });
    app.get("/getAllContexts", async (c) => {
        const agentInfo = await getAgentInfo(c);
        const contextsFull = await Promise.all(contexts.map(async (context) => ({
            id: context.id,
            name: context.name,
            description: context.description,
            data: await context.getContextData(agentInfo),
        })));
        return c.json(contextsFull);
    });
    app.get("/pinnables", (c) => {
        const pinnableInfo = pinnables.map((pinnable) => ({
            id: pinnable.id,
            type: pinnable.type,
            label: pinnable.label,
            name: pinnable.name,
            description: pinnable.description,
            icon: pinnable.icon,
            size: pinnable.size || "small",
        }));
        return c.json(pinnableInfo);
    });
    app.get("/pinnables/:pinnableId", async (c) => {
        const pinnable = pinnables.find((pinnable) => pinnable.id === c.req.param("pinnableId"));
        if (pinnable) {
            const agentInfo = await getAgentInfo(c);
            const widgetData = await pinnable.getWidget(agentInfo);
            return c.json({
                id: pinnable.id,
                type: pinnable.type,
                label: pinnable.label,
                name: pinnable.name,
                description: pinnable.description,
                icon: pinnable.icon,
                size: pinnable.size || "small",
                widget: widgetData,
            });
        }
        else {
            throw new http_exception_1.HTTPException(404, { message: "Pinnable not found" });
        }
    });
    app.get("/getAllPinnables", async (c) => {
        const agentInfo = await getAgentInfo(c);
        const pinnablesFull = await Promise.all(pinnables.map(async (pinnable) => ({
            id: pinnable.id,
            type: pinnable.type,
            label: pinnable.label,
            name: pinnable.name,
            description: pinnable.description,
            icon: pinnable.icon,
            size: pinnable.size || "small",
            widget: await pinnable.getWidget(agentInfo),
        })));
        return c.json(pinnablesFull);
    });
    app.get("/exampleQueries", (c) => {
        return c.json(config.exampleQueries || []);
    });
    // Services list endpoint
    app.get("/services", (c) => {
        const serviceInfo = services.map((service) => ({
            id: service.id,
            name: service.name,
            description: service.description,
            metadata: service.metadata,
            recommendedPrompt: service.recommendedPrompt,
            recommendedTools: service.recommendedTools.map((toolId) => {
                const tool = tools.find((t) => t.id === toolId);
                return tool ? { id: tool.id, name: tool.name } : toolId;
            }),
        }));
        return c.json(serviceInfo);
    });
    // Toolboxes list endpoint
    app.get("/toolboxes", (c) => c.json(toolboxes));
    // Automatically create routes for each tool
    tools.forEach((tool) => {
        app.post(`/tools/${tool.id}`, async (c) => {
            try {
                const agentInfo = await getAgentInfo(c);
                const body = await c.req.json();
                // Only use streaming if explicitly requested by options
                const wantsStream = c.req.header("Accept") === "text/event-stream";
                if (wantsStream) {
                    return (0, streaming_1.streamSSE)(c, async (stream) => {
                        try {
                            const result = await tool.handler({ ...body, DAIN_EXTRA_DATA: undefined }, agentInfo, {
                                app,
                                extraData: body.DAIN_EXTRA_DATA,
                                updateUI: async (update) => {
                                    await stream.writeSSE({
                                        event: 'uipage-update',
                                        data: JSON.stringify(update),
                                        id: Date.now().toString(),
                                    });
                                },
                                addProcess: async (processId) => {
                                    await stream.writeSSE({
                                        event: 'process-created',
                                        data: JSON.stringify({ processId }),
                                        id: Date.now().toString(),
                                    });
                                }
                            });
                            // Make sure we send the result event
                            await stream.writeSSE({
                                event: 'result',
                                data: JSON.stringify(result),
                                id: Date.now().toString(),
                            });
                        }
                        catch (error) {
                            console.error('Error in stream:', error);
                            throw error;
                        }
                    });
                }
                else {
                    // Non-streaming response - make sure we return a regular JSON response
                    const result = await tool.handler({ ...body, DAIN_EXTRA_DATA: undefined }, agentInfo, {
                        app,
                        extraData: body.DAIN_EXTRA_DATA
                    });
                    return c.json(result);
                }
            }
            catch (error) {
                console.error(`Error executing tool ${tool.id}:`, error);
                throw new http_exception_1.HTTPException(500, { message: "Internal server error" });
            }
        });
        // Update the executeAndGetNewContext route similarly
        app.post(`/tools/${tool.id}/executeAndGetNewContext`, async (c) => {
            try {
                const agentInfo = await getAgentInfo(c);
                const body = await c.req.json();
                const wantsStream = c.req.header("Accept") === "text/event-stream";
                if (wantsStream) {
                    return (0, streaming_1.streamSSE)(c, async (stream) => {
                        const result = await tool.handler({ ...body, DAIN_EXTRA_DATA: undefined }, agentInfo, {
                            app,
                            extraData: body.DAIN_EXTRA_DATA,
                            updateUI: async (update) => {
                                await stream.writeSSE({
                                    event: 'uipage-update',
                                    data: JSON.stringify(update),
                                });
                            },
                            addProcess: async (processId) => {
                                await stream.writeSSE({
                                    event: 'process-created',
                                    data: JSON.stringify({ processId }),
                                    id: Date.now().toString(),
                                });
                            }
                        });
                        const contextsNow = await Promise.all(contexts.map(async (context) => ({
                            id: context.id,
                            name: context.name,
                            description: context.description,
                            data: await context.getContextData(agentInfo),
                        })));
                        await stream.writeSSE({
                            event: 'result',
                            data: JSON.stringify({
                                toolResult: result,
                                context: contextsNow,
                            }),
                            id: Date.now().toString(),
                        });
                    });
                }
                else {
                    // Legacy non-streaming behavior
                    const result = await tool.handler({ ...body, DAIN_EXTRA_DATA: undefined }, agentInfo, {
                        app,
                        extraData: body.DAIN_EXTRA_DATA,
                    });
                    let contextsNow = await Promise.all(contexts.map(async (context) => ({
                        id: context.id,
                        name: context.name,
                        description: context.description,
                        data: await context.getContextData(agentInfo),
                    })));
                    return c.json({
                        toolResult: result,
                        context: contextsNow,
                    });
                }
            }
            catch (error) {
                console.error(`Error executing tool ${tool.id}:`, error);
                throw new http_exception_1.HTTPException(500, { message: "Internal server error" });
            }
        });
    });
    app.get("/getAllToolsAsJsonSchema", (c) => {
        const toolInfo = tools.map((tool) => ({
            id: tool.id,
            name: tool.name,
            description: tool.description,
            inputSchema: (0, zod_to_json_schema_1.default)(tool.input),
            outputSchema: (0, zod_to_json_schema_1.default)(tool.output),
            suggestConfirmation: tool.suggestConfirmation,
        }));
        return c.json({
            tools: toolInfo,
            reccomendedPrompts: toolboxes.map((toolbox) => toolbox.recommendedPrompt),
        });
    });
    // Detailed info for a specific tool
    app.get("/tools/:toolId", (c) => {
        const tool = tools.find((t) => t.id === c.req.param("toolId"));
        if (tool) {
            const toolDetails = {
                id: tool.id,
                name: tool.name,
                description: tool.description,
                pricing: tool.pricing,
                inputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(tool.input),
                outputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(tool.output),
                suggestConfirmation: tool.suggestConfirmation,
            };
            return c.json(toolDetails);
        }
        else {
            throw new http_exception_1.HTTPException(404, { message: "Tool not found" });
        }
    });
    // Detailed info for a specific service
    app.get("/services/:serviceId", (c) => {
        const service = services.find((s) => s.id === c.req.param("serviceId"));
        if (service) {
            const serviceDetails = {
                id: service.id,
                name: service.name,
                description: service.description,
                metadata: service.metadata,
                recommendedPrompt: service.recommendedPrompt,
                recommendedTools: service.recommendedTools.map((toolId) => {
                    const tool = tools.find((t) => t.id === toolId);
                    return tool
                        ? {
                            id: tool.id,
                            name: tool.name,
                            description: tool.description,
                            pricing: tool.pricing,
                            inputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(tool.input),
                            outputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(tool.output),
                        }
                        : {
                            id: toolId,
                            name: "Unknown Tool",
                            description: "Tool not found",
                        };
                }),
            };
            return c.json(serviceDetails);
        }
        else {
            throw new http_exception_1.HTTPException(404, { message: "Service not found" });
        }
    });
    // Detailed info for a specific toolbox
    app.get("/toolboxes/:toolboxId", (c) => {
        const toolbox = toolboxes.find((t) => t.id === c.req.param("toolboxId"));
        if (toolbox) {
            return c.json(toolbox);
        }
        else {
            throw new http_exception_1.HTTPException(404, { message: "Toolbox not found" });
        }
    });
    // Health check endpoint
    app.get("/health", (c) => c.json({ status: "healthy", timestamp: new Date().toISOString() }));
    // Setup custom routes if provided
    if (config.routes) {
        config.routes(app);
    }
    if (config.oauth2?.providers) {
        if (!config.oauth2?.baseUrl) {
            throw new Error("config.oauth2.baseUrl is required for OAuth2");
        }
        const oauth2Handler = new oauth2_1.OAuth2Handler(bs58_1.default.encode(privateKey), config.oauth2.baseUrl, config.oauth2.tokenStore);
        // Register providers
        Object.entries(config.oauth2.providers).forEach(([name, providerConfig]) => {
            oauth2Handler.registerProvider(name, providerConfig);
        });
        // OAuth callback route
        app.get("/oauth2/callback/:provider", async (c) => {
            if (!app.oauth2) {
                throw new http_exception_1.HTTPException(404, { message: "OAuth2 not configured" });
            }
            const provider = c.req.param("provider");
            const code = c.req.query("code");
            const state = c.req.query("state");
            if (!code || !state) {
                throw new http_exception_1.HTTPException(400, { message: "Missing code or state" });
            }
            try {
                await app.oauth2.handleCallback(code, state);
                return c.html(`
          <html>
            <body>
              <script>
                window.opener.postMessage({ type: 'oauth2-success', provider: '${provider}' }, '*');
                window.close();
              </script>
              <h1>Authentication successful! You can close this window.</h1>
            </body>
          </html>
        `);
            }
            catch (error) {
                console.error("OAuth callback error:", error);
                return c.html(`
          <html>
            <body>
              <script>
                window.opener.postMessage({ type: 'oauth2-error', provider: '${provider}', error: '${error.message}' }, '*');
                window.close();
              </script>
              <h1>Authentication failed! You can close this window.</h1>
            </body>
          </html>
        `);
            }
        });
        // Make oauth2Handler available to tools
        app.oauth2 = oauth2Handler;
    }
    // Add new route for process status with agent verification
    app.get("/processes/:processId/status", async (c) => {
        const processId = c.req.param("processId");
        const agentInfo = await getAgentInfo(c);
        try {
            const status = await app.processes.getProcessStatus(processId, agentInfo.id);
            if (!status) {
                throw new http_exception_1.HTTPException(404, { message: "Process not found" });
            }
            return c.json(status);
        }
        catch (error) {
            if (error.message === "Unauthorized access to process") {
                throw new http_exception_1.HTTPException(403, { message: "Unauthorized access to process" });
            }
            throw error;
        }
    });
    // Get all OAuth providers and connection status
    app.get("/oauth2/providers", async (c) => {
        if (!app.oauth2) {
            return c.json([]);
        }
        const agentInfo = await getAgentInfo(c);
        const providers = await app.oauth2.getProviders(agentInfo.agentId);
        // Get connection status for each provider
        const providersWithStatus = await Promise.all(providers.map(async ({ name, config }) => ({
            name,
            config,
            connected: await app.oauth2.hasValidTokens(name, agentInfo.id)
        })));
        return c.json(providersWithStatus);
    });
    // Get auth URL for specific provider
    app.get("/oauth2/connect/:provider", async (c) => {
        if (!app.oauth2) {
            throw new http_exception_1.HTTPException(404, { message: "OAuth2 not configured" });
        }
        const provider = c.req.param("provider");
        const agentInfo = await getAgentInfo(c);
        try {
            const authUrl = await app.oauth2.generateAuthUrl(provider, agentInfo.id);
            return c.json({ authUrl });
        }
        catch (error) {
            throw new http_exception_1.HTTPException(400, {
                message: `Invalid provider: ${provider}`
            });
        }
    });
    // Get all human actions for a process
    app.get("/processes/:processId/human-actions", async (c) => {
        const processId = c.req.param("processId");
        const agentInfo = await getAgentInfo(c);
        const process = await app.processes.getProcess(processId);
        if (!process) {
            throw new http_exception_1.HTTPException(404, { message: "Process not found" });
        }
        if (process.agentId !== agentInfo.id) {
            console.log("Unauthorized access to process", process.agentId, agentInfo.id);
            throw new http_exception_1.HTTPException(403, { message: "Unauthorized access to process" });
        }
        return c.json(process.humanActions);
    });
    // Get specific human action
    app.get("/processes/:processId/human-actions/:stepId", async (c) => {
        console.log('GET human action request:', c.req.path);
        const processId = c.req.param("processId");
        const stepId = c.req.param("stepId");
        const agentInfo = await getAgentInfo(c);
        const process = await app.processes.getProcess(processId);
        if (!process) {
            throw new http_exception_1.HTTPException(404, { message: "Process not found" });
        }
        if (process.agentId !== agentInfo.id) {
            console.log("Unauthorized access to process", process.agentId, agentInfo.id);
            throw new http_exception_1.HTTPException(403, { message: "Unauthorized access to process" });
        }
        const step = await app.processes.checkHumanAction(processId, stepId);
        if (!step) {
            throw new http_exception_1.HTTPException(404, { message: "Human action not found" });
        }
        return c.json(step);
    });
    // Respond to human action
    app.post("/processes/:processId/human-actions/:stepId/respond", async (c) => {
        const processId = c.req.param("processId");
        const stepId = c.req.param("stepId");
        const agentInfo = await getAgentInfo(c);
        const process = await app.processes.getProcess(processId);
        if (!process) {
            throw new http_exception_1.HTTPException(404, { message: "Process not found" });
        }
        if (process.agentId !== agentInfo.id) {
            console.log("Unauthorized access to process", process.agentId, agentInfo.id);
            throw new http_exception_1.HTTPException(403, { message: "Unauthorized access to process" });
        }
        const body = await c.req.json();
        const { actionId, responseText, data } = body;
        if (!actionId) {
            throw new http_exception_1.HTTPException(400, { message: "actionId is required" });
        }
        try {
            await app.processes.respondToHumanAction(processId, stepId, actionId, responseText, data);
            return c.json({ success: true });
        }
        catch (error) {
            throw new http_exception_1.HTTPException(400, { message: error.message });
        }
    });
    // Add new endpoint for getting confirmation UI
    app.post(`/tools/:toolId/confirmation`, async (c) => {
        const tool = tools.find((t) => t.id === c.req.param("toolId"));
        if (!tool) {
            throw new http_exception_1.HTTPException(404, { message: "Tool not found" });
        }
        if (!tool.suggestConfirmationUI) {
            return c.json({ success: true }); // Default to success if no UI generator
        }
        try {
            const body = await c.req.json();
            const confirmationUI = await tool.suggestConfirmationUI(body);
            return c.json(confirmationUI);
        }
        catch (error) {
            console.error(`Error generating confirmation UI for tool ${tool.id}:`, error);
            throw new http_exception_1.HTTPException(500, { message: "Error generating confirmation UI" });
        }
    });
    return app;
}
//# sourceMappingURL=server.js.map