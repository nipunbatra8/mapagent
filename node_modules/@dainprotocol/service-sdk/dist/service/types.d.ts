import { z, ZodError } from "zod";
import { ExecutionContext, Hono } from "hono";
import { PaymentIntent } from "@/lib/payments";
import { OAuth2Handler } from "./oauth2";
import { Process, ProcessHandler, ProcessStoreAdapter } from "./processes";
import { ServerType } from "@hono/node-server/.";
export type AgentInfo = {
    agentId: string;
    address: string;
    smartAccountPDA?: string;
    id: string;
    webhookUrl?: string;
};
export type PricingInfo = {
    pricePerUse: number;
    currency: string;
};
export type Metadata = {
    title: string;
    description: string;
    logo?: string;
    version: string;
    author: string;
    tags: string[];
};
export type Identity = {
    publicKey?: string;
    privateKey?: string;
    agentId?: string;
    orgId?: string;
    apiKey?: string;
};
export type ToolContext = {
    app: Hono;
    extraData?: any;
    updateUI?: (update: {
        ui: any;
    }) => Promise<void>;
    addProcess?: (processId: string) => Promise<void>;
};
export type ToolConfig<TInput extends z.ZodType = any, TOutput extends z.ZodType = any> = {
    id: string;
    name: string;
    description: string;
    input: TInput;
    output: TOutput;
    pricing?: PricingInfo;
    suggestConfirmation?: boolean;
    suggestConfirmationUI?: (input: z.input<TInput>) => Promise<{
        success?: boolean;
        ui?: any;
    }>;
    handler: (input: z.input<TInput>, agentInfo: AgentInfo, context: ToolContext) => Promise<{
        text: string;
        data: z.output<TOutput>;
        ui: any | undefined;
        pleasePay?: PaymentIntent | undefined;
        processes?: string[] | {
            id: string;
            name: string;
            description: string;
            type: "one-time" | "recurring";
        }[];
    }>;
    handleInputError?: (error: ZodError, agentInfo: AgentInfo, extraData?: any) => Promise<{
        text: string;
        data: z.output<TOutput>;
        ui: any | undefined;
        recommendedNextTool?: string;
        pleasePay?: PaymentIntent | undefined;
        processes?: string[] | {
            id: string;
            name: string;
            description: string;
            type: "one-time" | "recurring";
        }[];
    }>;
};
export type ServiceConfig = {
    id: string;
    name: string;
    description: string;
    metadata: {
        capabilities: string[];
        languages: string[];
    };
    recommendedPrompt: string;
    recommendedTools: string[];
};
export type ServiceContext = {
    id: string;
    name: string;
    description: string;
    getContextData: (agentInfo: AgentInfo) => Promise<string>;
};
export type ServicePinnable = {
    id: string;
    type: "button" | "widget";
    label: string;
    name: string;
    size?: "small" | "large";
    description: string;
    icon: string;
    getWidget: (agentInfo: AgentInfo) => Promise<{
        text?: string;
        data?: any;
        ui?: any;
    }>;
};
export type ToolboxConfig = {
    id: string;
    name: string;
    description: string;
    tools: string[];
    metadata: {
        complexity: string;
        applicableFields: string[];
    };
    recommendedPrompt: string;
};
export interface DAINService {
    startNode: (options?: {
        port?: number;
    }) => Promise<ServiceManager>;
    startDeno: (options?: {
        port?: number;
    }) => Promise<ServiceManager>;
    startWorkers: () => (request: Request, Env?: unknown, executionCtx?: ExecutionContext) => Response | Promise<Response>;
    getMetadata: () => Metadata;
    getServices: () => ServiceConfig[];
    getContexts: () => ServiceContext[];
    getTools: () => ToolConfig[];
    getToolboxes: () => ToolboxConfig[];
    findTool: (toolId: string) => ToolConfig | undefined;
    findToolbox: (toolboxId: string) => ToolboxConfig | undefined;
    findService: (serviceId: string) => ServiceConfig | undefined;
    app: Hono;
    startService: () => Hono;
}
export interface NodeServerExtension {
    connect: (app: Hono, server: ServerType) => void;
    [key: string]: any;
}
export type DAINServiceConfig = {
    metadata: Metadata;
    identity: Identity;
    services?: ServiceConfig[];
    tools: ToolConfig[];
    toolboxes?: ToolboxConfig[];
    routes?: (app: Hono) => void;
    serverExtensions?: NodeServerExtension[];
    contexts?: ServiceContext[];
    pinnables?: ServicePinnable[];
    oauth2?: OAuth2Config & {
        baseUrl: string;
        tokenStore?: OAuth2TokenStoreAdapter;
    };
    processStore?: ProcessStoreAdapter;
    exampleQueries?: {
        category: string;
        queries: string[];
    }[];
    baseUrl?: string;
    onHumanActionResponse?: (response: {
        process: Process;
        stepId: string;
        actionId: string;
        responseText?: string;
        data?: any;
    }) => Promise<void>;
};
export interface ServiceManager {
    shutdown: () => Promise<void>;
    address: () => {
        port: number;
    };
    app: DAINHono;
}
export interface DAINPlugin {
    initialize: (service: DAINService) => Promise<void>;
}
export type ServerEnvironment = "node" | "deno" | "cloudflare" | "custom";
export interface OAuth2ProviderConfig {
    clientId: string;
    clientSecret: string;
    authorizationUrl: string;
    tokenUrl: string;
    scopes: string[];
    usePKCE?: boolean;
    useBasicAuth?: boolean;
    reason?: string;
    requiredTools?: string[];
    onSuccess?: (agentId: string, tokens: OAuth2Tokens) => Promise<void>;
    extraAuthParams?: Record<string, string>;
    responseRootKey?: string;
}
export type OAuth2Config = {
    providers: Record<string, OAuth2ProviderConfig>;
};
export interface OAuth2Tokens {
    accessToken: string;
    refreshToken?: string;
    scope?: string;
    createdAt?: number;
}
export interface OAuth2TokenStoreAdapter {
    saveTokens(agentId: string, provider: string, tokens: OAuth2Tokens): Promise<void>;
    getTokens(agentId: string, provider: string): Promise<OAuth2Tokens | null>;
    hasValidTokens(agentId: string, provider: string): Promise<boolean>;
    deleteTokens(agentId: string, provider: string): Promise<void>;
}
export interface DAINHono extends Hono {
    processes?: ProcessHandler;
    oauth2?: OAuth2Handler;
}
declare module "hono" {
    interface Hono {
        oauth2?: OAuth2Handler;
        processes?: ProcessHandler;
    }
}
