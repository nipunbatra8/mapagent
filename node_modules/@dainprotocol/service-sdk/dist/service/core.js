"use strict";
// File: src/service/core.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoreUtils = void 0;
exports.createTool = createTool;
exports.createService = createService;
exports.createContext = createContext;
exports.createPinnable = createPinnable;
exports.createToolbox = createToolbox;
exports.validateAgentInfo = validateAgentInfo;
exports.calculatePrice = calculatePrice;
exports.generateId = generateId;
exports.sanitizeTags = sanitizeTags;
exports.mergeToolboxes = mergeToolboxes;
exports.validatePricing = validatePricing;
exports.isToolInToolbox = isToolInToolbox;
exports.createOAuth2Tool = createOAuth2Tool;
const zod_1 = require("zod");
function createTool(config) {
    // Validate the config
    if (!config.id || !config.name || !config.description) {
        throw new Error("Tool config is missing required fields");
    }
    // Ensure the handler respects the input and output schemas
    const wrappedHandler = async (input, agentInfo, context) => {
        let parsedInput;
        try {
            parsedInput = config.input.parse(input);
        }
        catch (error) {
            if (error instanceof zod_1.z.ZodError) {
                const missingParams = error.issues
                    .map((issue) => issue.path.join("."))
                    .join(", ");
                if (config.handleInputError) {
                    const errorResult = await config.handleInputError(error, agentInfo, context);
                    // Expand process IDs in error handler result
                    let expandedProcesses;
                    if (errorResult.processes?.length) {
                        expandedProcesses = await Promise.all(errorResult.processes.map(async (process) => {
                            if (typeof process === "string") {
                                const processInfo = await context.app.processes.getProcess(process);
                                return {
                                    id: process,
                                    name: processInfo.name,
                                    description: processInfo.description,
                                    type: processInfo.type,
                                };
                            }
                            return process;
                        }));
                    }
                    return {
                        ...errorResult,
                        processes: expandedProcesses,
                    };
                }
                return {
                    text: `Error: Missing or invalid parameters for this tool call- '${missingParams}', Please ask the user to provide the missing values, or try again with the correct parameters.`,
                    data: {},
                    ui: {
                        type: "error",
                        message: `Please provide valid values for: ${missingParams}`,
                    },
                };
            }
            throw error;
        }
        const result = await config.handler(parsedInput, agentInfo, {
            app: context.app,
            extraData: context.extraData,
            updateUI: context.updateUI,
            addProcess: context.addProcess,
        });
        // If processes is a string array, expand it
        let expandedProcesses;
        if (Array.isArray(result.processes)) {
            if (result.processes.length > 0 &&
                typeof result.processes[0] === "string") {
                expandedProcesses = await Promise.all(result.processes.map(async (processId) => {
                    const processInfo = await context.app.processes.getProcess(processId);
                    if (!processInfo)
                        throw new Error(`Process ${processId} not found`);
                    return {
                        id: processId,
                        name: processInfo.name,
                        description: processInfo.description,
                        type: processInfo.type,
                    };
                }));
            }
            else {
                expandedProcesses = result.processes;
            }
        }
        return {
            text: result.text,
            data: config.output.parse(result.data),
            ui: result.ui,
            pleasePay: result.pleasePay,
            processes: expandedProcesses,
        };
    };
    return {
        ...config,
        handler: wrappedHandler,
    };
}
function createService(config) {
    // Validate the config
    if (!config.id || !config.name || !config.description) {
        throw new Error("Service config is missing required fields");
    }
    // Validate metadata
    if (!config.metadata.capabilities || !config.metadata.languages) {
        throw new Error("Service metadata is incomplete");
    }
    return {
        ...config,
        recommendedTools: config.recommendedTools || [],
    };
}
function createContext(config) {
    return config;
}
function createPinnable(config) {
    return config;
}
function createToolbox(config) {
    // Validate the config
    if (!config.id ||
        !config.name ||
        !config.description ||
        !config.tools.length) {
        throw new Error("Toolbox config is missing required fields");
    }
    // Validate metadata
    if (!config.metadata.complexity || !config.metadata.applicableFields) {
        throw new Error("Toolbox metadata is incomplete");
    }
    return config;
}
// Utility function to validate agent info
function validateAgentInfo(agentInfo) {
    return !!(agentInfo.agentId && agentInfo.address);
}
// Utility function to calculate price for tool usage
function calculatePrice(pricing, usageCount) {
    return pricing.pricePerUse * usageCount;
}
// Utility function to generate a unique ID
function generateId(prefix) {
    return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}
// Utility function to validate and sanitize metadata tags
function sanitizeTags(tags) {
    return tags.map((tag) => tag.toLowerCase().trim()).filter(Boolean);
}
// Utility function to merge toolboxes
function mergeToolboxes(toolboxes) {
    if (toolboxes.length === 0) {
        throw new Error("No toolboxes provided for merging");
    }
    const mergedTools = new Set();
    const mergedApplicableFields = new Set();
    toolboxes.forEach((toolbox) => {
        toolbox.tools.forEach((tool) => mergedTools.add(tool));
        toolbox.metadata.applicableFields.forEach((field) => mergedApplicableFields.add(field));
    });
    return {
        id: generateId("merged_toolbox"),
        name: "Merged Toolbox",
        description: "A toolbox merged from multiple toolboxes",
        tools: Array.from(mergedTools),
        metadata: {
            complexity: "Mixed",
            applicableFields: Array.from(mergedApplicableFields),
        },
        recommendedPrompt: "This toolbox contains a variety of tools from multiple domains.",
    };
}
// Utility function to validate pricing info
function validatePricing(pricing) {
    return pricing.pricePerUse >= 0 && !!pricing.currency;
}
// Utility function to check if a tool is part of a toolbox
function isToolInToolbox(toolId, toolbox) {
    return toolbox.tools.includes(toolId);
}
exports.CoreUtils = {
    validateAgentInfo,
    calculatePrice,
    generateId,
    sanitizeTags,
    mergeToolboxes,
    validatePricing,
    isToolInToolbox,
};
function createOAuth2Tool(provider, prefix = "") {
    return createTool({
        id: prefix ? `${prefix}-oauth2-${provider}` : `oauth2-${provider}`,
        name: `${provider} OAuth Login`,
        description: `Authenticate with ${provider}`,
        input: zod_1.z.object({}),
        output: zod_1.z.object({
            authUrl: zod_1.z.string(),
        }),
        pricing: {
            pricePerUse: 0,
            currency: "USD",
        },
        handler: async (_, agentInfo, { app, extraData }) => {
            // Destructure both app and extraData
            if (!app.oauth2) {
                throw new Error("OAuth2 not configured for this service");
            }
            const authUrl = await app.oauth2.generateAuthUrl(provider, agentInfo.id);
            return {
                text: `Please authenticate with ${provider} using this URL: ${authUrl}`,
                data: { authUrl },
                ui: {
                    type: "oauth2",
                    uiData: JSON.stringify({
                        title: `${provider} Authentication`,
                        content: `Please authenticate with ${provider} to continue`,
                        url: authUrl,
                        provider: provider,
                    }),
                },
            };
        },
    });
}
//# sourceMappingURL=core.js.map