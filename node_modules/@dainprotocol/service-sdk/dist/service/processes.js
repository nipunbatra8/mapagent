"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessHandler = exports.UpstashProcessStore = exports.RedisProcessStore = exports.MemoryProcessStore = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const utils_1 = require("@noble/hashes/utils");
const ed25519_1 = require("@noble/curves/ed25519");
const sha256_1 = require("@noble/hashes/sha256");
const ioredis_1 = require("ioredis");
const cuid2_1 = require("@paralleldrive/cuid2");
const service_1 = require("./service");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
// In-memory adapter implementation
class MemoryProcessStore {
    processes = new Map();
    async saveProcess(process) {
        this.processes.set(process.id, process);
    }
    async getProcess(processId) {
        return this.processes.get(processId) || null;
    }
    async updateProcess(processId, updates) {
        const process = this.processes.get(processId);
        if (process) {
            this.processes.set(processId, { ...process, ...updates });
        }
    }
    async getHumanAction(processId, stepId) {
        const process = await this.getProcess(processId);
        if (!process)
            return null;
        return process.humanActions.find(step => step.id === stepId) || null;
    }
    async updateHumanAction(processId, stepId, updates) {
        const process = await this.getProcess(processId);
        if (!process)
            throw new Error("Process not found");
        const stepIndex = process.humanActions.findIndex(step => step.id === stepId);
        if (stepIndex === -1)
            throw new Error("Human action step not found");
        process.humanActions[stepIndex] = {
            ...process.humanActions[stepIndex],
            ...updates
        };
        await this.saveProcess(process);
    }
}
exports.MemoryProcessStore = MemoryProcessStore;
class RedisProcessStore {
    redis;
    prefix = "process:";
    constructor(redisUrl) {
        this.redis = new ioredis_1.Redis(redisUrl || process.env.REDIS_URL, {
            // Recommended serverless settings
            maxRetriesPerRequest: 1,
            enableReadyCheck: false,
            reconnectOnError: () => false,
        });
    }
    async saveProcess(process) {
        await this.redis.set(this.prefix + process.id, JSON.stringify(process));
    }
    async getProcess(processId) {
        const data = await this.redis.get(this.prefix + processId);
        if (!data)
            return null;
        return JSON.parse(data);
    }
    async updateProcess(processId, updates) {
        const process = await this.getProcess(processId);
        if (!process)
            throw new Error("Process not found");
        const updatedProcess = { ...process, ...updates };
        await this.saveProcess(updatedProcess);
    }
    async getHumanAction(processId, stepId) {
        const process = await this.getProcess(processId);
        if (!process)
            return null;
        return process.humanActions.find(step => step.id === stepId) || null;
    }
    async updateHumanAction(processId, stepId, updates) {
        const process = await this.getProcess(processId);
        if (!process)
            throw new Error("Process not found");
        const stepIndex = process.humanActions.findIndex(step => step.id === stepId);
        if (stepIndex === -1)
            throw new Error("Human action step not found");
        process.humanActions[stepIndex] = {
            ...process.humanActions[stepIndex],
            ...updates
        };
        await this.saveProcess(process);
    }
}
exports.RedisProcessStore = RedisProcessStore;
class UpstashProcessStore {
    baseUrl;
    token;
    constructor() {
        this.baseUrl = process.env.UPSTASH_REDIS_REST_URL;
        this.token = process.env.UPSTASH_REDIS_REST_TOKEN;
    }
    async fetchRedis(command, pipeline = false) {
        const response = await fetch(this.baseUrl + (pipeline ? "/pipeline" : ""), {
            method: "POST",
            headers: {
                Authorization: `Bearer ${this.token}`,
                "Content-Type": "application/json",
            },
            body: JSON.stringify(pipeline ? command : command),
        });
        return await response.json();
    }
    async saveProcess(process) {
        await this.fetchRedis([
            "SET",
            `process:${process.id}`,
            JSON.stringify(process),
        ]);
    }
    async getProcess(processId) {
        const result = await this.fetchRedis(["GET", `process:${processId}`]);
        if (!result.result)
            return null;
        return JSON.parse(result.result);
    }
    async updateProcess(processId, updates) {
        const process = await this.getProcess(processId);
        if (!process)
            throw new Error("Process not found");
        const updatedProcess = { ...process, ...updates };
        await this.saveProcess(updatedProcess);
    }
    async getHumanAction(processId, stepId) {
        const process = await this.getProcess(processId);
        if (!process)
            return null;
        return process.humanActions.find(step => step.id === stepId) || null;
    }
    async updateHumanAction(processId, stepId, updates) {
        const process = await this.getProcess(processId);
        if (!process)
            throw new Error("Process not found");
        const stepIndex = process.humanActions.findIndex(step => step.id === stepId);
        if (stepIndex === -1)
            throw new Error("Human action step not found");
        process.humanActions[stepIndex] = {
            ...process.humanActions[stepIndex],
            ...updates
        };
        await this.saveProcess(process);
    }
}
exports.UpstashProcessStore = UpstashProcessStore;
class ProcessHandler {
    store;
    serviceId;
    privateKey;
    baseUrl;
    onHumanActionResponse;
    constructor({ serviceId, privateKey, apiKey, store, baseUrl, onHumanActionResponse, }) {
        if (apiKey) {
            const identity = (0, service_1.parseApiKey)(apiKey);
            this.serviceId = "service_" + identity.orgId + "_" + identity.agentId;
            this.privateKey = bs58_1.default.decode(identity.privateKey);
        }
        else {
            this.serviceId = serviceId || (0, cuid2_1.createId)();
            this.privateKey = privateKey;
        }
        this.baseUrl = baseUrl;
        this.store = store || new MemoryProcessStore();
        this.onHumanActionResponse = onHumanActionResponse;
    }
    generateProcessId() {
        return `${this.serviceId}_${Date.now()}_${(0, cuid2_1.createId)()}`;
    }
    signWebhookPayload(payload) {
        const timestamp = Date.now().toString();
        const message = JSON.stringify({ ...payload, timestamp });
        const messageHash = (0, sha256_1.sha256)(message);
        const signature = ed25519_1.ed25519.sign(messageHash, this.privateKey);
        return { signature: (0, utils_1.bytesToHex)(signature), timestamp };
    }
    async createProcess(agentInfo, type, name, description) {
        const processId = this.generateProcessId();
        const process = {
            id: processId,
            name: name || "Process " + processId,
            description: description || "Process " + processId,
            agentId: agentInfo.id,
            webhookUrl: agentInfo.webhookUrl,
            type,
            status: "running",
            updates: [],
            results: [],
            agentInfo,
            humanActions: [],
        };
        await this.store.saveProcess(process);
        if (process.webhookUrl) {
            try {
                const payload = {
                    type: "process_created",
                    processId,
                    agentId: agentInfo.id,
                    process: {
                        id: processId,
                        name: process.name,
                        description: process.description,
                        type: process.type,
                        agentId: agentInfo.id,
                    },
                    serviceId: this.serviceId,
                };
                const { signature, timestamp } = this.signWebhookPayload(payload);
                await axios_1.default.post(process.webhookUrl, payload, {
                    headers: {
                        "X-DAIN-SIGNATURE": signature,
                        "X-DAIN-TIMESTAMP": timestamp,
                        "X-DAIN-PROCESS-ID": processId,
                    },
                });
            }
            catch (error) {
                console.error("Failed to send webhook for process creation:", error);
            }
        }
        return processId;
    }
    async addUpdate(processId, update) {
        const process = await this.store.getProcess(processId);
        if (!process)
            throw new Error("Process not found");
        const fullUpdate = {
            ...update,
            createdAt: new Date(),
        };
        process.updates.push(fullUpdate);
        await this.store.updateProcess(processId, { updates: process.updates });
        if (process.webhookUrl) {
            try {
                const payload = {
                    type: "process_update",
                    processId,
                    agentId: process.agentId,
                    update: fullUpdate,
                    serviceId: this.serviceId,
                };
                const { signature, timestamp } = this.signWebhookPayload(payload);
                await axios_1.default.post(process.webhookUrl, payload, {
                    headers: {
                        "X-DAIN-SIGNATURE": signature,
                        "X-DAIN-TIMESTAMP": timestamp,
                        "X-DAIN-PROCESS-ID": processId,
                    },
                });
            }
            catch (error) {
                console.error("Failed to send webhook update:", error);
            }
        }
    }
    async addResult(processId, result) {
        const process = await this.store.getProcess(processId);
        if (!process)
            throw new Error("Process not found");
        process.results.push(result);
        if (process.type === "one-time") {
            process.status = "completed";
        }
        await this.store.updateProcess(processId, {
            results: process.results,
            status: process.status,
        });
        if (process.webhookUrl) {
            try {
                const payload = {
                    type: "process_result",
                    processId,
                    agentId: process.agentId,
                    result,
                    isComplete: process.type === "one-time",
                    serviceId: this.serviceId,
                };
                const { signature, timestamp } = this.signWebhookPayload(payload);
                await axios_1.default.post(process.webhookUrl, payload, {
                    headers: {
                        "X-DAIN-SIGNATURE": signature,
                        "X-DAIN-TIMESTAMP": timestamp,
                        "X-DAIN-PROCESS-ID": processId,
                    },
                });
            }
            catch (error) {
                console.error("Failed to send webhook result:", error);
            }
        }
    }
    async getProcess(processId) {
        return await this.store.getProcess(processId);
    }
    async failProcess(processId, error) {
        const process = await this.store.getProcess(processId);
        if (!process)
            throw new Error("Process not found");
        process.status = "failed";
        await this.store.updateProcess(processId, { status: "failed" });
        if (process.webhookUrl) {
            try {
                const payload = {
                    type: "process_failed",
                    processId,
                    agentId: process.agentId,
                    error,
                    serviceId: this.serviceId,
                };
                const { signature, timestamp } = this.signWebhookPayload(payload);
                await axios_1.default.post(process.webhookUrl, payload, {
                    headers: {
                        "X-DAIN-SIGNATURE": signature,
                        "X-DAIN-TIMESTAMP": timestamp,
                        "X-DAIN-PROCESS-ID": processId,
                    },
                });
            }
            catch (error) {
                console.error("Failed to send webhook failure:", error);
            }
        }
    }
    async getProcessStatus(processId, agentId) {
        const process = await this.store.getProcess(processId);
        if (!process)
            return null;
        if (process.agentId !== agentId) {
            throw new Error("Unauthorized access to process");
        }
        return {
            id: process.id,
            status: process.status,
            updates: process.updates,
            results: process.results,
            humanActions: process.humanActions || [],
        };
    }
    async requestHumanAction(processId, options) {
        const process = await this.store.getProcess(processId);
        if (!process)
            throw new Error("Process not found");
        const stepId = (0, cuid2_1.createId)();
        const actionsWithCallbacks = options.actions.map(action => ({
            ...action,
            callbackUrl: this.baseUrl
                ? `${this.baseUrl}/processes/${processId}/human-actions/${stepId}/respond`
                : undefined
        }));
        const step = {
            id: stepId,
            processId,
            message: options.message,
            ui: options.ui,
            actions: actionsWithCallbacks,
            status: 'pending',
            createdAt: new Date(),
            timeoutAt: options.timeoutMs ? new Date(Date.now() + options.timeoutMs) : undefined,
            _metadata: options.metadata
        };
        if (!process.humanActions) {
            process.humanActions = [];
        }
        process.humanActions.push(step);
        await this.store.saveProcess(process);
        if (process.webhookUrl) {
            try {
                const { _metadata, ...stepWithoutMetadata } = step;
                const payload = {
                    type: "human_action_requested",
                    processId,
                    agentId: process.agentId,
                    serviceId: this.serviceId,
                    step: stepWithoutMetadata
                };
                const { signature, timestamp } = this.signWebhookPayload(payload);
                await axios_1.default.post(process.webhookUrl, payload, {
                    headers: {
                        "X-DAIN-SIGNATURE": signature,
                        "X-DAIN-TIMESTAMP": timestamp,
                        "X-DAIN-PROCESS-ID": processId,
                    },
                });
            }
            catch (error) {
                console.error("Failed to send human action webhook:", error);
            }
        }
        // Set up timeout if specified
        if (options.timeoutMs) {
            setTimeout(async () => {
                const currentStep = await this.store.getHumanAction(processId, stepId);
                if (currentStep && currentStep.status === 'pending') {
                    await this.store.updateHumanAction(processId, stepId, {
                        status: 'timeout'
                    });
                }
            }, options.timeoutMs);
        }
        return stepId;
    }
    async checkHumanAction(processId, stepId) {
        const step = await this.store.getHumanAction(processId, stepId);
        if (!step)
            throw new Error("Human action step not found");
        return {
            status: step.status,
            response: step.response
        };
    }
    async waitForHumanAction(processId, stepId, timeoutMs = 300000 // Default 5 minute timeout
    ) {
        return new Promise(async (resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject(new Error("Waiting for human action timed out"));
            }, timeoutMs);
            const checkStatus = async () => {
                try {
                    const status = await this.checkHumanAction(processId, stepId);
                    switch (status.status) {
                        case 'completed':
                            clearTimeout(timeoutId);
                            if (!status.response) {
                                reject(new Error("No response found for completed action"));
                                return;
                            }
                            resolve(status.response);
                            break;
                        case 'failed':
                        case 'timeout':
                            clearTimeout(timeoutId);
                            reject(new Error(`Human action ${status.status}`));
                            break;
                        case 'pending':
                            setTimeout(checkStatus, 1000); // Poll every second
                            break;
                    }
                }
                catch (error) {
                    clearTimeout(timeoutId);
                    reject(error);
                }
            };
            await checkStatus();
        });
    }
    async respondToHumanAction(processId, stepId, actionId, responseText, data) {
        const step = await this.store.getHumanAction(processId, stepId);
        if (!step)
            throw new Error("Human action step not found");
        if (step.status !== 'pending')
            throw new Error("Human action is no longer pending");
        // Validate action ID
        const validAction = step.actions.find(action => action.id === actionId);
        if (!validAction) {
            throw new Error(`Invalid action ID: ${actionId}`);
        }
        // Check if response is required but missing
        if (validAction.requiresResponse && !responseText) {
            throw new Error(`Response text is required for action: ${actionId}`);
        }
        const response = {
            actionId,
            responseText,
            timestamp: new Date(),
            data
        };
        const process = await this.store.getProcess(processId);
        if (!process)
            throw new Error("Process not found");
        await this.store.updateHumanAction(processId, stepId, {
            status: 'completed',
            response
        });
        // Notify service handler if configured
        if (this.onHumanActionResponse) {
            await this.onHumanActionResponse({
                process,
                stepId,
                actionId,
                responseText,
                data
            });
        }
        if (process.webhookUrl) {
            try {
                const { _metadata, ...stepWithoutMetadata } = step;
                const payload = {
                    type: "human_action_completed",
                    processId,
                    agentId: process.agentId,
                    serviceId: this.serviceId,
                    step: {
                        ...stepWithoutMetadata,
                        status: 'completed',
                        response
                    }
                };
                const { signature, timestamp } = this.signWebhookPayload(payload);
                await axios_1.default.post(process.webhookUrl, payload, {
                    headers: {
                        "X-DAIN-SIGNATURE": signature,
                        "X-DAIN-TIMESTAMP": timestamp,
                        "X-DAIN-PROCESS-ID": processId,
                    },
                });
            }
            catch (error) {
                console.error("Failed to send human action completion webhook:", error);
            }
        }
    }
}
exports.ProcessHandler = ProcessHandler;
//# sourceMappingURL=processes.js.map