"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const api_sdk_1 = require("../client/api-sdk");
const client_auth_1 = require("../client/client-auth");
const ed25519_1 = require("@noble/curves/ed25519");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
const nodeService_1 = require("../service/nodeService");
const zod_1 = require("zod");
const oauth2Store_1 = require("../service/oauth2Store");
const hono_1 = require("hono");
const node_server_1 = require("@hono/node-server");
describe("OAuth Integration", () => {
    const privateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const publicKey = ed25519_1.ed25519.getPublicKey(privateKey);
    const clientPrivateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const clientPublicKey = ed25519_1.ed25519.getPublicKey(clientPrivateKey);
    const agentAuth = new client_auth_1.DainClientAuth({
        privateKeyBase58: bs58_1.default.encode(clientPrivateKey),
        agentId: "agent-12",
        orgId: "org-12",
    });
    const mockTokenStore = new oauth2Store_1.InMemoryOAuth2TokenStore();
    let oauthServer;
    let oauthSdk;
    let oauth2Handler;
    let mockOAuthProvider;
    beforeAll(async () => {
        // Create mock OAuth provider server
        const mockOAuthApp = new hono_1.Hono();
        // Add auth endpoint
        mockOAuthApp.get('/auth', (c) => {
            return c.redirect(c.req.query('redirect_uri') +
                '?code=test-code&state=' + c.req.query('state'));
        });
        mockOAuthApp.post('/token', async (c) => {
            const body = await c.req.parseBody();
            // Verify the expected OAuth token request
            if (body.grant_type === 'authorization_code' &&
                body.client_id === 'test-client-id' &&
                body.client_secret === 'test-client-secret' &&
                body.code === 'test-code') {
                return c.json({
                    access_token: 'mock_access_token',
                    token_type: 'Bearer',
                    expires_in: 3600,
                    refresh_token: 'mock_refresh_token',
                    scope: 'test_scope',
                });
            }
            return c.json({ error: 'invalid_request' }, 400);
        });
        const mockOAuthServer = (0, node_server_1.serve)({
            fetch: mockOAuthApp.fetch,
            port: 4455
        });
        // Update the OAuth service config to use mock server
        const oauthService = (0, nodeService_1.defineDAINService)({
            metadata: {
                title: "Test OAuth Service",
                description: "A test OAuth service",
                version: "1.0.0",
                author: "Test Author",
                tags: ["test", "oauth"],
            },
            identity: {
                publicKey: bs58_1.default.encode(publicKey),
                agentId: "test-agent",
                orgId: "test-org",
                privateKey: bs58_1.default.encode(privateKey),
            },
            oauth2: {
                baseUrl: "http://localhost:4422",
                tokenStore: mockTokenStore,
                providers: {
                    test_provider: {
                        clientId: "test-client-id",
                        clientSecret: "test-client-secret",
                        authorizationUrl: "http://localhost:4455/auth", // Point to mock server
                        tokenUrl: "http://localhost:4455/token", // Point to mock server
                        scopes: ["test_scope"],
                        reason: "Required for testing",
                        requiredTools: ["test-oauth-tool"],
                        onSuccess: async (agentId, tokens) => {
                            console.log("OAuth success", agentId, tokens);
                        },
                    },
                },
            },
            tools: [
                (0, nodeService_1.createTool)({
                    id: "test-oauth-tool",
                    name: "Test OAuth Tool",
                    description: "Tool that requires OAuth",
                    input: zod_1.z.object({}),
                    output: zod_1.z.object({ success: zod_1.z.boolean() }),
                    pricing: { pricePerUse: 0.01, currency: "USD" },
                    handler: async () => ({
                        text: "OAuth test",
                        data: { success: true },
                        ui: null,
                    }),
                }),
            ],
        });
        const service = await oauthService.startService();
        oauthServer = await oauthService.startNode({ port: 4422 });
        oauthSdk = new api_sdk_1.DainSDK("http://localhost:4422", agentAuth);
        await oauthSdk.initialize();
        oauth2Handler = service.oauth2;
        mockOAuthProvider = mockOAuthServer;
    });
    afterAll(async () => {
        if (oauthServer) {
            await oauthServer.shutdown();
        }
        if (mockOAuthProvider) {
            await mockOAuthProvider.close();
        }
    });
    describe("Provider Management", () => {
        it("should list available OAuth providers", async () => {
            const providers = await oauthSdk.getOAuthProviders();
            expect(providers).toHaveLength(1);
            expect(providers[0].name).toBe("test_provider");
            expect(providers[0].config.reason).toBe("Required for testing");
            expect(providers[0].config.scopes).toEqual(["test_scope"]);
            expect(providers[0].config.requiredTools).toEqual(["test-oauth-tool"]);
        });
        it("should generate OAuth connect URL", async () => {
            const url = await oauthSdk.getOAuthConnectUrl("test_provider");
            expect(url).toContain("http://localhost:4455/auth");
            expect(url).toContain("client_id=test-client-id");
            expect(url).toContain("scope=test_scope");
        });
        it("should throw error for invalid provider", async () => {
            await expect(oauthSdk.getOAuthConnectUrl("invalid_provider"))
                .rejects
                .toThrow();
        });
    });
    describe("Tool Requirements", () => {
        it("should identify tools requiring OAuth", async () => {
            const requirements = await oauthSdk.getToolOAuthRequirements("test-oauth-tool");
            expect(requirements.required).toBe(true);
            expect(requirements.providers).toHaveLength(1);
            expect(requirements.providers[0].name).toBe("test_provider");
            expect(requirements.providers[0].reason).toBe("Required for testing");
        });
        it("should handle tools without OAuth requirements", async () => {
            const noOAuthTool = (0, nodeService_1.createTool)({
                id: "no-oauth-tool",
                name: "No OAuth Tool",
                description: "Tool that doesn't require OAuth",
                input: zod_1.z.object({}),
                output: zod_1.z.object({}),
                pricing: { pricePerUse: 0.01, currency: "USD" },
                handler: async () => ({
                    text: "No OAuth",
                    data: {},
                    ui: null,
                }),
            });
            const service = (0, nodeService_1.defineDAINService)({
                metadata: {
                    title: "Test OAuth Service",
                    description: "A test OAuth service",
                    version: "1.0.0",
                    author: "Test Author",
                    tags: ["test", "oauth"],
                },
                identity: {
                    publicKey: bs58_1.default.encode(publicKey),
                    agentId: "test-agent",
                    orgId: "test-org",
                    privateKey: bs58_1.default.encode(privateKey),
                },
                oauth2: {
                    baseUrl: "http://localhost:4423",
                    tokenStore: mockTokenStore,
                    providers: {
                        test_provider: {
                            clientId: "test-client-id",
                            clientSecret: "test-client-secret",
                            authorizationUrl: "https://test.com/auth",
                            tokenUrl: "https://test.com/token",
                            scopes: ["test_scope"],
                            reason: "Required for testing",
                            requiredTools: ["test-oauth-tool"],
                            onSuccess: async (agentId, tokens) => {
                                console.log("OAuth success", agentId, tokens);
                            },
                        },
                    },
                },
                tools: [(0, nodeService_1.createTool)({
                        id: "test-oauth-tool",
                        name: "Test OAuth Tool",
                        description: "Tool that requires OAuth",
                        input: zod_1.z.object({}),
                        output: zod_1.z.object({ success: zod_1.z.boolean() }),
                        pricing: { pricePerUse: 0.01, currency: "USD" },
                        handler: async () => ({
                            text: "OAuth test",
                            data: { success: true },
                            ui: null,
                        }),
                    }), noOAuthTool],
            });
            const newServer = await service.startNode({ port: 4423 });
            const newSdk = new api_sdk_1.DainSDK("http://localhost:4423", agentAuth);
            await newSdk.initialize();
            const requirements = await newSdk.getToolOAuthRequirements("no-oauth-tool");
            expect(requirements.required).toBe(false);
            expect(requirements.providers).toHaveLength(0);
            await newServer.shutdown();
        });
    });
    describe("Documentation", () => {
        it("should include OAuth requirements in documentation", async () => {
            const docs = await oauthSdk.getDocumentation();
            expect(docs).toContain("## OAuth Requirements");
            expect(docs).toContain("test_provider");
            expect(docs).toContain("Required for testing");
            expect(docs).toContain("test_scope");
            expect(docs).toContain("**OAuth Requirements:**");
            expect(docs).toContain("test_provider: Required for testing");
        });
    });
    describe("Token Management", () => {
        it("should check OAuth requirements before executing tool", async () => {
            // @ts-ignore - Accessing generated method
            await expect(oauthSdk.testOauthTool({}))
                .rejects
                .toThrow(/Missing required OAuth connections/);
        });
        it("should store and validate tokens", async () => {
            const code = "test-code";
            const state = await oauth2Handler.encodeState({
                agentId: "address_" + bs58_1.default.encode(clientPublicKey),
                provider: "test_provider",
                timestamp: Date.now(),
            });
            const response = await fetch(`http://localhost:4422/oauth2/callback/test_provider?code=${code}&state=${state}`);
            expect(response.status).toBe(200);
            console.log(await response.text());
            // Add a small delay to ensure token processing is complete
            await new Promise(resolve => setTimeout(resolve, 100));
            const requirements = await oauthSdk.getToolOAuthRequirements("test-oauth-tool");
            console.log(requirements);
            expect(requirements.providers[0].connected).toBe(true);
        });
    });
    describe("PKCE and Basic Auth", () => {
        let pkceServer;
        let pkceSdk;
        beforeAll(async () => {
            // Create mock OAuth provider with PKCE support
            const mockPKCEApp = new hono_1.Hono();
            // Add auth endpoint that validates PKCE parameters
            mockPKCEApp.get('/auth', (c) => {
                const codeChallenge = c.req.query('code_challenge');
                const codeChallengeMethod = c.req.query('code_challenge_method');
                // Verify PKCE parameters are present
                if (!codeChallenge || codeChallengeMethod !== 'S256') {
                    return c.json({ error: 'invalid_request' }, 400);
                }
                return c.redirect(c.req.query('redirect_uri') +
                    '?code=pkce-test-code&state=' + c.req.query('state'));
            });
            // Add token endpoint that validates PKCE code verifier and Basic Auth
            mockPKCEApp.post('/token', async (c) => {
                const authHeader = c.req.header('Authorization');
                const body = await c.req.parseBody();
                // Verify Basic Auth
                const expectedAuth = 'Basic ' + Buffer.from('pkce-client-id:pkce-client-secret').toString('base64');
                if (authHeader !== expectedAuth) {
                    return c.json({ error: 'invalid_client' }, 401);
                }
                // Verify PKCE code verifier is present
                if (!body.code_verifier) {
                    return c.json({ error: 'invalid_request' }, 400);
                }
                return c.json({
                    access_token: 'pkce_access_token',
                    token_type: 'Bearer',
                    expires_in: 3600,
                    refresh_token: 'pkce_refresh_token',
                    scope: 'pkce_scope',
                });
            });
            const mockPKCEServer = (0, node_server_1.serve)({
                fetch: mockPKCEApp.fetch,
                port: 4456
            });
            // Create service with PKCE and Basic Auth enabled
            const pkceService = (0, nodeService_1.defineDAINService)({
                metadata: {
                    title: "PKCE OAuth Test Service",
                    description: "Testing PKCE and Basic Auth",
                    version: "1.0.0",
                    author: "Test Author",
                    tags: ["test", "oauth", "pkce"],
                },
                identity: {
                    publicKey: bs58_1.default.encode(publicKey),
                    privateKey: bs58_1.default.encode(privateKey),
                    agentId: "test-agent",
                    orgId: "test-org",
                },
                oauth2: {
                    baseUrl: "http://localhost:4424",
                    tokenStore: new oauth2Store_1.InMemoryOAuth2TokenStore(),
                    providers: {
                        pkce_provider: {
                            clientId: "pkce-client-id",
                            clientSecret: "pkce-client-secret",
                            authorizationUrl: "http://localhost:4456/auth",
                            tokenUrl: "http://localhost:4456/token",
                            scopes: ["pkce_scope"],
                            reason: "Testing PKCE flow",
                            requiredTools: ["pkce-test-tool"],
                            usePKCE: true,
                            useBasicAuth: true,
                        },
                    },
                },
                tools: [
                    (0, nodeService_1.createTool)({
                        id: "pkce-test-tool",
                        name: "PKCE Test Tool",
                        description: "Tool for testing PKCE flow",
                        input: zod_1.z.object({}),
                        output: zod_1.z.object({ success: zod_1.z.boolean() }),
                        handler: async () => ({
                            text: "PKCE test",
                            data: { success: true },
                            ui: null,
                        }),
                    }),
                ],
            });
            pkceServer = await pkceService.startNode({ port: 4424 });
            pkceSdk = new api_sdk_1.DainSDK("http://localhost:4424", agentAuth);
            await pkceSdk.initialize();
        });
        afterAll(async () => {
            if (pkceServer) {
                await pkceServer.shutdown();
            }
        });
        it("should generate auth URL with PKCE parameters", async () => {
            const url = await pkceSdk.getOAuthConnectUrl("pkce_provider");
            const urlParams = new URL(url).searchParams;
            expect(urlParams.get('code_challenge')).toBeTruthy();
            expect(urlParams.get('code_challenge_method')).toBe('S256');
        });
        it("should complete PKCE flow with Basic Auth", async () => {
            const url = await pkceSdk.getOAuthConnectUrl("pkce_provider");
            const urlParams = new URL(url).searchParams;
            const state = urlParams.get('state');
            // Simulate callback with auth code
            const response = await fetch(`http://localhost:4424/oauth2/callback/pkce_provider?code=pkce-test-code&state=${state}`);
            expect(response.status).toBe(200);
            // Wait for token processing
            await new Promise(resolve => setTimeout(resolve, 100));
            // Verify connection status
            const requirements = await pkceSdk.getToolOAuthRequirements("pkce-test-tool");
            expect(requirements.providers[0].connected).toBe(true);
        });
    });
});
//# sourceMappingURL=oauth.test.js.map