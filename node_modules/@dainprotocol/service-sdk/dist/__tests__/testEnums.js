"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const zod_1 = require("zod");
const schemaStructure_1 = require("../lib/schemaStructure");
const convertToVercelTool_1 = require("../lib/convertToVercelTool");
describe('Enum types conversion', () => {
    it('should correctly convert enum types to Vercel AI Tool parameters', () => {
        // Define a schema with enum fields
        const testSchema = zod_1.z.object({
            simpleEnum: zod_1.z.enum(['A', 'B', 'C']),
            optionalEnum: zod_1.z.enum(['X', 'Y', 'Z']).optional(),
            nestedEnum: zod_1.z.object({
                innerEnum: zod_1.z.enum(['inner1', 'inner2', 'inner3'])
            })
        });
        // Create a mock HTTP tool
        const httpTool = {
            id: 'test-enum-tool',
            name: 'Test Enum Tool',
            description: 'A tool to test enum field conversion',
            inputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(testSchema),
            outputSchema: { type: 'ZodAny' }
        };
        // Convert the HTTP tool to a Vercel AI Tool
        const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(httpTool);
        // Check if the conversion was successful
        expect(vercelAITool.name).toBe('test-enum-tool');
        expect(vercelAITool.description).toBe('A tool to test enum field conversion');
        expect(vercelAITool.parameters).toBeInstanceOf(zod_1.z.ZodObject);
        // Check if the fields are correctly converted
        const schemaShape = vercelAITool.parameters._def.shape();
        expect(schemaShape.simpleEnum).toBeInstanceOf(zod_1.z.ZodEnum);
        expect(schemaShape.optionalEnum).toBeInstanceOf(zod_1.z.ZodOptional);
        expect(schemaShape.optionalEnum._def.innerType).toBeInstanceOf(zod_1.z.ZodEnum);
        expect(schemaShape.nestedEnum).toBeInstanceOf(zod_1.z.ZodObject);
        expect(schemaShape.nestedEnum._def.shape().innerEnum).toBeInstanceOf(zod_1.z.ZodEnum);
        // Test parsing with the converted schema
        const validInput = {
            simpleEnum: 'B',
            optionalEnum: 'Y',
            numberEnum: 2,
            mixedEnum: 'one',
            nestedEnum: {
                innerEnum: 'inner2'
            }
        };
        const parseResult = vercelAITool.parameters.safeParse(validInput);
        expect(parseResult.success).toBe(true);
        // Test parsing with invalid enum values
        const invalidInput = {
            simpleEnum: 'D',
            numberEnum: 4,
            mixedEnum: false,
            nestedEnum: {
                innerEnum: 'inner4'
            }
        };
        const invalidParseResult = vercelAITool.parameters.safeParse(invalidInput);
        expect(invalidParseResult.success).toBe(false);
        // Test parsing with missing optional enum
        const minimalInput = {
            simpleEnum: 'A',
            numberEnum: 1,
            mixedEnum: true,
            nestedEnum: {
                innerEnum: 'inner1'
            }
        };
        const minimalParseResult = vercelAITool.parameters.safeParse(minimalInput);
        expect(minimalParseResult.success).toBe(true);
    });
});
//# sourceMappingURL=testEnums.js.map