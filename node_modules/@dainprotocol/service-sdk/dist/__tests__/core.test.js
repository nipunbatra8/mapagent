"use strict";
// File: src/__tests__/core.test.ts
Object.defineProperty(exports, "__esModule", { value: true });
const zod_1 = require("zod");
const core_1 = require("../service/core");
describe("DAIN Framework Core", () => {
    const mockAgentInfo = {
        agentId: "test-agent",
        address: "1234567890123456789012345678901234567890",
        smartAccountPDA: "1234567890123456789012345678901234567890",
        id: "dain_id_1234567890123456789012345678901234567890",
    };
    test("createTool creates a valid tool configuration", async () => {
        const toolConfig = {
            id: "get-weather",
            name: "Get Weather",
            description: "Fetches weather for a city",
            input: zod_1.z.object({ city: zod_1.z.string() }),
            output: zod_1.z.object({ temperature: zod_1.z.number() }),
            pricing: { pricePerUse: 0.01, currency: "USD" },
            handler: async (input) => ({
                text: `Temperature for ${input.city} is ${input.city.length}°C`,
                data: { temperature: input.city.length },
                ui: null
            }), // Mock implementation
        };
        const tool = (0, core_1.createTool)(toolConfig);
        expect(tool.id).toBe(toolConfig.id);
        expect(tool.name).toBe(toolConfig.name);
        expect(tool.description).toBe(toolConfig.description);
        expect(tool.input).toBe(toolConfig.input);
        expect(tool.output).toBe(toolConfig.output);
        expect(tool.pricing).toBe(toolConfig.pricing);
        // Test the wrapped handler
        const result = await tool.handler({ city: "New York" }, mockAgentInfo, { app: {}, extraData: {} });
        expect(result).toEqual({
            data: { temperature: 8 },
            text: "Temperature for New York is 8°C",
            ui: null
        });
    });
    test("createTool throws an error for invalid input", async () => {
        const tool = (0, core_1.createTool)({
            id: "test-tool",
            name: "Test Tool",
            description: "A test tool",
            input: zod_1.z.object({ value: zod_1.z.number() }),
            output: zod_1.z.object({ result: zod_1.z.string() }),
            pricing: { pricePerUse: 0.01, currency: "USD" },
            handler: async (input) => ({
                text: input.value.toString(),
                data: { result: input.value.toString() },
                ui: null
            }),
        });
        await expect(await tool.handler({ value: "not a number" }, mockAgentInfo, { app: {}, extraData: {} })).toEqual({ "data": {}, "text": "Error: Missing or invalid parameters for this tool call- 'value', Please ask the user to provide the missing values, or try again with the correct parameters.", "ui": { "message": "Please provide valid values for: value", "type": "error" } });
    });
    test("createService creates a valid service configuration", () => {
        const serviceConfig = {
            id: "weather-service",
            name: "Weather Service",
            description: "Provides weather information",
            metadata: {
                capabilities: ["current-weather", "forecast"],
                languages: ["en", "es"],
            },
            recommendedPrompt: "Ask about the weather",
            recommendedTools: ["get-weather", "get-forecast"],
        };
        const service = (0, core_1.createService)(serviceConfig);
        expect(service).toEqual(serviceConfig);
    });
    test("createToolbox creates a valid toolbox configuration", () => {
        const toolboxConfig = {
            id: "weather-toolbox",
            name: "Weather Toolbox",
            description: "Collection of weather tools",
            tools: ["get-weather", "get-forecast"],
            metadata: {
                complexity: "Low",
                applicableFields: ["Meteorology", "Travel"],
            },
            recommendedPrompt: "Use these tools for weather-related tasks",
        };
        const toolbox = (0, core_1.createToolbox)(toolboxConfig);
        expect(toolbox).toEqual(toolboxConfig);
    });
    test("validateAgentInfo validates agent info correctly", () => {
        expect(core_1.CoreUtils.validateAgentInfo(mockAgentInfo)).toBe(true);
        expect(core_1.CoreUtils.validateAgentInfo({ agentId: "test" })).toBe(false);
    });
    test("calculatePrice calculates price correctly", () => {
        const pricing = { pricePerUse: 0.01, currency: "USD" };
        expect(core_1.CoreUtils.calculatePrice(pricing, 5)).toBe(0.05);
    });
    test("generateId generates a unique ID", () => {
        const id1 = core_1.CoreUtils.generateId("test");
        const id2 = core_1.CoreUtils.generateId("test");
        expect(id1).not.toBe(id2);
        expect(id1.startsWith("test_")).toBe(true);
    });
    test("sanitizeTags sanitizes tags correctly", () => {
        const tags = ["Tag1", " tag2 ", "TAG3", ""];
        expect(core_1.CoreUtils.sanitizeTags(tags)).toEqual(["tag1", "tag2", "tag3"]);
    });
    test("mergeToolboxes merges toolboxes correctly", () => {
        const toolbox1 = {
            id: "toolbox1",
            name: "Toolbox 1",
            description: "First toolbox",
            tools: ["tool1", "tool2"],
            metadata: {
                complexity: "Low",
                applicableFields: ["Field1", "Field2"],
            },
            recommendedPrompt: "Prompt 1",
        };
        const toolbox2 = {
            id: "toolbox2",
            name: "Toolbox 2",
            description: "Second toolbox",
            tools: ["tool2", "tool3"],
            metadata: {
                complexity: "Medium",
                applicableFields: ["Field2", "Field3"],
            },
            recommendedPrompt: "Prompt 2",
        };
        const mergedToolbox = core_1.CoreUtils.mergeToolboxes([toolbox1, toolbox2]);
        expect(mergedToolbox.tools).toEqual(expect.arrayContaining(["tool1", "tool2", "tool3"]));
        expect(mergedToolbox.metadata.applicableFields).toEqual(expect.arrayContaining(["Field1", "Field2", "Field3"]));
    });
    test("validatePricing validates pricing info correctly", () => {
        expect(core_1.CoreUtils.validatePricing({ pricePerUse: 0.01, currency: "USD" })).toBe(true);
        expect(core_1.CoreUtils.validatePricing({ pricePerUse: -1, currency: "USD" })).toBe(false);
        expect(core_1.CoreUtils.validatePricing({ pricePerUse: 0.01, currency: "" })).toBe(false);
    });
    test("isToolInToolbox checks if a tool is in a toolbox", () => {
        const toolbox = {
            id: "test-toolbox",
            name: "Test Toolbox",
            description: "A test toolbox",
            tools: ["tool1", "tool2"],
            metadata: {
                complexity: "Low",
                applicableFields: ["Test"],
            },
            recommendedPrompt: "Test prompt",
        };
        expect(core_1.CoreUtils.isToolInToolbox("tool1", toolbox)).toBe(true);
        expect(core_1.CoreUtils.isToolInToolbox("tool3", toolbox)).toBe(false);
    });
});
//# sourceMappingURL=core.test.js.map