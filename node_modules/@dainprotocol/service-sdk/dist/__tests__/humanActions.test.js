"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ed25519_1 = require("@noble/curves/ed25519");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
const nodeService_1 = require("../service/nodeService");
const zod_1 = require("zod");
const client_auth_1 = require("../client/client-auth");
const http_1 = require("http");
const client_1 = require("../client/client");
describe("Human Action Handler", () => {
    const privateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const publicKey = ed25519_1.ed25519.getPublicKey(privateKey);
    const clientPrivateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    let webhookCalls = [];
    let webhookServer;
    const WEBHOOK_PORT = 3098;
    const SERVICE_PORT = 3019;
    const agentAuth = new client_auth_1.DainClientAuth({
        privateKeyBase58: bs58_1.default.encode(clientPrivateKey),
        agentId: "agent-12",
        orgId: "org-12",
        webhookUrl: `http://localhost:${WEBHOOK_PORT}/webhooks`
    });
    const humanActionTool = (0, nodeService_1.createTool)({
        id: "human-action-test",
        name: "Human Action Test",
        description: "Tests human-in-the-loop functionality",
        input: zod_1.z.object({
            message: zod_1.z.string(),
            requireResponse: zod_1.z.boolean().optional(),
            timeout: zod_1.z.number().optional()
        }),
        output: zod_1.z.object({
            stepId: zod_1.z.string(),
            status: zod_1.z.string()
        }),
        handler: async ({ message, requireResponse, timeout }, agentInfo, { app }) => {
            const processId = await app.processes.createProcess(agentInfo, "one-time", "Human Action Test", "Testing human-in-the-loop functionality");
            const stepId = await app.processes.requestHumanAction(processId, {
                message,
                actions: [
                    {
                        id: "approve",
                        title: "Approve",
                        requiresResponse: requireResponse
                    },
                    {
                        id: "deny",
                        title: "Deny"
                    }
                ],
                timeoutMs: timeout
            });
            return {
                text: "Waiting for human action",
                data: { stepId, processId, status: "pending" },
                ui: { type: "humanAction", uiData: JSON.stringify({ processId, stepId }) },
                processes: [processId]
            };
        }
    });
    const dainService = (0, nodeService_1.defineDAINService)({
        metadata: {
            title: "Human Action Test Service",
            description: "Testing human-in-the-loop functionality",
            version: "1.0.0",
            author: "Test Author",
            tags: ["test"],
        },
        identity: {
            publicKey: bs58_1.default.encode(publicKey),
            agentId: "test-agent",
            orgId: "test-org",
            privateKey: bs58_1.default.encode(privateKey),
        },
        tools: [humanActionTool],
        baseUrl: `http://localhost:${SERVICE_PORT}`
    });
    let server;
    let connection;
    beforeAll(async () => {
        webhookServer = (0, http_1.createServer)((req, res) => {
            let body = '';
            req.on('data', chunk => { body += chunk.toString(); });
            req.on('end', () => {
                webhookCalls.push({
                    headers: req.headers,
                    body: JSON.parse(body)
                });
                res.writeHead(200);
                res.end('OK');
            });
        });
        await new Promise(resolve => {
            webhookServer.listen(WEBHOOK_PORT, () => resolve());
        });
        server = await dainService.startNode({ port: SERVICE_PORT });
        connection = new client_1.DainServiceConnection(`http://localhost:${SERVICE_PORT}`, agentAuth);
        await connection.getMetadata();
    });
    afterAll(async () => {
        if (server)
            await server.shutdown();
        if (webhookServer)
            await new Promise(resolve => webhookServer.close(resolve));
    });
    beforeEach(() => {
        webhookCalls = [];
    });
    describe("Human Action Flow", () => {
        it("should create and complete a human action successfully", async () => {
            const result = await connection.callTool("human-action-test", {
                message: "Please approve this action"
            });
            console.log('Tool response:', result);
            expect(result.processes).toHaveLength(1);
            const processId = result.processes[0].id;
            const stepId = result.data.stepId;
            console.log('Making request to:', `/processes/${processId}/human-actions/${stepId}`);
            // Get the human action details
            const actionDetails = await connection.getHumanAction(processId, stepId);
            expect(actionDetails.status).toBe("pending");
            // Respond to the human action
            await connection.respondToHumanAction(processId, stepId, "approve");
            // Wait for completion webhook
            await new Promise(resolve => setTimeout(resolve, 100));
            const actionCompleted = webhookCalls.find(call => call.body.type === "human_action_completed");
            expect(actionCompleted).toBeDefined();
            expect(actionCompleted.body.step.status).toBe("completed");
            expect(actionCompleted.body.step.response.actionId).toBe("approve");
        });
        it("should handle required response text", async () => {
            const result = await connection.callTool("human-action-test", {
                message: "Please approve with comment",
                requireResponse: true
            });
            // Wait for webhook
            await new Promise(resolve => setTimeout(resolve, 100));
            const actionRequest = webhookCalls.find(call => call.body.type === "human_action_requested");
            const { processId } = actionRequest.body;
            const stepId = result.data.stepId;
            // Try to respond without required text
            await expect(connection.respondToHumanAction(processId, stepId, "approve")).rejects.toThrow();
            // Respond with required text
            await connection.respondToHumanAction(processId, stepId, "approve", "Looks good!");
            const completed = webhookCalls.find(call => call.body.type === "human_action_completed");
            expect(completed.body.step.response.responseText).toBe("Looks good!");
        });
        it("should handle timeouts", async () => {
            const result = await connection.callTool("human-action-test", {
                message: "This will timeout",
                timeout: 100
            });
            expect(result.processes).toHaveLength(1);
            const processId = result.processes[0].id;
            const stepId = result.data.stepId;
            // Wait for timeout
            await new Promise(resolve => setTimeout(resolve, 200));
            const status = await connection.getHumanAction(processId, stepId);
            expect(status.status).toBe("timeout");
        });
        it("should validate action IDs", async () => {
            const result = await connection.callTool("human-action-test", {
                message: "Testing invalid action"
            });
            expect(result.processes).toHaveLength(1);
            const processId = result.processes[0].id;
            const stepId = result.data.stepId;
            // Try to respond with invalid action ID
            await expect(connection.respondToHumanAction(processId, stepId, "invalid_action")).rejects.toThrow();
        });
        it("should trigger onHumanActionResponse callback", async () => {
            // Create a mock callback
            const mockCallback = jest.fn();
            // Create service with callback
            const serviceWithCallback = (0, nodeService_1.defineDAINService)({
                metadata: {
                    title: "Human Action Test Service",
                    description: "Testing human-in-the-loop functionality",
                    version: "1.0.0",
                    author: "Test Author",
                    tags: ["test"],
                },
                identity: {
                    publicKey: bs58_1.default.encode(publicKey),
                    agentId: "test-agent",
                    orgId: "test-org",
                    privateKey: bs58_1.default.encode(privateKey),
                },
                tools: [humanActionTool],
                baseUrl: `http://localhost:${SERVICE_PORT}`,
                onHumanActionResponse: mockCallback
            });
            const serverWithCallback = await serviceWithCallback.startNode({ port: SERVICE_PORT + 1 });
            const connectionWithCallback = new client_1.DainServiceConnection(`http://localhost:${SERVICE_PORT + 1}`, agentAuth);
            await connectionWithCallback.getMetadata();
            // Make the request
            const result = await connectionWithCallback.callTool("human-action-test", {
                message: "Please approve this action"
            });
            const processId = result.processes[0].id;
            const stepId = result.data.stepId;
            // Respond to the human action
            await connectionWithCallback.respondToHumanAction(processId, stepId, "approve", "Test response");
            // Verify callback was called with correct data
            expect(mockCallback).toHaveBeenCalledTimes(1);
            expect(mockCallback).toHaveBeenCalledWith(expect.objectContaining({
                process: expect.objectContaining({
                    id: processId,
                    status: "running"
                }),
                stepId,
                actionId: "approve",
                responseText: "Test response"
            }));
            await serverWithCallback.shutdown();
        });
    });
});
//# sourceMappingURL=humanActions.test.js.map