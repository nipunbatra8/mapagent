"use strict";
//File: src/___tests___/convertToVercelTool.test.ts
Object.defineProperty(exports, "__esModule", { value: true });
const convertToVercelTool_1 = require("../lib/convertToVercelTool");
const zod_1 = require("zod");
describe('HTTP to Vercel AI Tool Converter', () => {
    it('should convert a simple HTTP tool output to a Vercel AI tool format', () => {
        const httpToolOutput = {
            id: 'get-weather',
            name: 'Get Weather',
            description: 'Fetches weather for a city',
            pricing: { pricePerUse: 0.01, currency: 'USD' },
            inputSchema: {
                type: 'ZodObject',
                shape: {
                    city: {
                        type: 'ZodString',
                        description: 'The name of the city'
                    },
                    country: {
                        type: 'ZodString',
                        description: 'The country of the city'
                    }
                }
            },
            outputSchema: {
                type: 'ZodObject',
                shape: {
                    temperature: { type: 'ZodNumber' },
                    condition: { type: 'ZodString' }
                }
            }
        };
        const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(httpToolOutput);
        expect(vercelAITool).toEqual({
            name: 'get-weather',
            description: 'Fetches weather for a city',
            parameters: expect.any(zod_1.z.ZodObject),
            returnSchema: expect.any(zod_1.z.ZodObject),
        });
        const params = vercelAITool.parameters.safeParse({
            city: 'New York',
            country: 'USA',
        });
        expect(params.success).toBe(true);
        // Use Zod's built-in methods to inspect the schema
        const schemaShape = vercelAITool.parameters._def.shape();
        expect(schemaShape.city.description).toBe('The name of the city');
        expect(schemaShape.country.description).toBe('The country of the city');
    });
    it('should handle complex schemas with nested objects, arrays, and unions', () => {
        const complexHttpToolOutput = {
            id: 'complex-tool',
            name: 'Complex Tool',
            description: 'A tool with a complex schema',
            inputSchema: {
                type: 'ZodObject',
                shape: {
                    simpleField: { type: 'ZodString', description: 'A simple string field' },
                    arrayField: {
                        type: 'ZodArray',
                        element: { type: 'ZodNumber', description: 'Array of numbers' },
                        description: 'An array field'
                    },
                    nestedObject: {
                        type: 'ZodObject',
                        shape: {
                            nestedField: { type: 'ZodBoolean', description: 'A nested boolean field' }
                        },
                        description: 'A nested object'
                    },
                    unionField: {
                        type: 'ZodUnion',
                        options: [
                            { type: 'ZodString', description: 'String option' },
                            { type: 'ZodNumber', description: 'Number option' }
                        ],
                        description: 'A union field'
                    }
                }
            },
            outputSchema: { type: 'ZodAny' }
        };
        const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(complexHttpToolOutput);
        expect(vercelAITool.name).toBe('complex-tool');
        expect(vercelAITool.parameters).toBeInstanceOf(zod_1.z.ZodObject);
        const schemaShape = vercelAITool.parameters._def.shape();
        expect(schemaShape.simpleField).toBeInstanceOf(zod_1.z.ZodString);
        expect(schemaShape.arrayField).toBeInstanceOf(zod_1.z.ZodArray);
        expect(schemaShape.nestedObject).toBeInstanceOf(zod_1.z.ZodObject);
        expect(schemaShape.unionField).toBeInstanceOf(zod_1.z.ZodUnion);
        const validInput = {
            simpleField: 'test',
            arrayField: [1, 2, 3],
            nestedObject: { nestedField: true },
            unionField: 'string'
        };
        const parseResult = vercelAITool.parameters.safeParse(validInput);
        expect(parseResult.success).toBe(true);
    });
    it('should handle ZodOptional schema', () => {
        const httpToolOutput = {
            id: 'optional-tool',
            name: 'Optional Tool',
            description: 'A tool with optional fields',
            inputSchema: {
                type: 'ZodObject',
                shape: {
                    requiredField: { type: 'ZodString', description: 'A required field' },
                    optionalField: {
                        type: 'ZodOptional',
                        innerType: { type: 'ZodString' },
                        description: 'An optional field'
                    }
                }
            },
            outputSchema: { type: 'ZodAny' }
        };
        const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(httpToolOutput);
        const schemaShape = vercelAITool.parameters._def.shape();
        expect(schemaShape.requiredField).toBeInstanceOf(zod_1.z.ZodString);
        expect(schemaShape.optionalField).toBeInstanceOf(zod_1.z.ZodOptional);
        expect(schemaShape.optionalField._def.innerType).toBeInstanceOf(zod_1.z.ZodString);
        const validInput1 = { requiredField: 'test' };
        const validInput2 = { requiredField: 'test', optionalField: 'optional' };
        const invalidInput = { optionalField: 'missing required field' };
        expect(vercelAITool.parameters.safeParse(validInput1).success).toBe(true);
        expect(vercelAITool.parameters.safeParse(validInput2).success).toBe(true);
        expect(vercelAITool.parameters.safeParse(invalidInput).success).toBe(false);
    });
    it('should handle ZodEnum schema', () => {
        const httpToolOutput = {
            id: 'enum-tool',
            name: 'Enum Tool',
            description: 'A tool with enum fields',
            inputSchema: {
                type: 'ZodObject',
                shape: {
                    enumField: {
                        type: 'ZodEnum',
                        values: ['option1', 'option2', 'option3'],
                        description: 'An enum field'
                    }
                }
            },
            outputSchema: { type: 'ZodAny' }
        };
        const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(httpToolOutput);
        const schemaShape = vercelAITool.parameters._def.shape();
        expect(schemaShape.enumField).toBeInstanceOf(zod_1.z.ZodEnum);
        const validInput = { enumField: 'option2' };
        const invalidInput = { enumField: 'invalidOption' };
        expect(vercelAITool.parameters.safeParse(validInput).success).toBe(true);
        expect(vercelAITool.parameters.safeParse(invalidInput).success).toBe(false);
    });
    it('should handle ZodNullable schema', () => {
        const httpToolOutput = {
            id: 'nullable-tool',
            name: 'Nullable Tool',
            description: 'A tool with nullable fields',
            inputSchema: {
                type: 'ZodObject',
                shape: {
                    nullableField: {
                        type: 'ZodNullable',
                        innerType: { type: 'ZodString' },
                        description: 'A nullable field'
                    }
                }
            },
            outputSchema: { type: 'ZodAny' }
        };
        const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(httpToolOutput);
        const schemaShape = vercelAITool.parameters._def.shape();
        expect(schemaShape.nullableField).toBeInstanceOf(zod_1.z.ZodNullable);
        const validInput1 = { nullableField: 'test' };
        const validInput2 = { nullableField: null };
        expect(vercelAITool.parameters.safeParse(validInput1).success).toBe(true);
        expect(vercelAITool.parameters.safeParse(validInput2).success).toBe(true);
    });
    it('should handle ZodRecord schema with different key types', () => {
        const httpToolOutput = {
            id: 'record-tool',
            name: 'Record Tool',
            description: 'A tool with record fields',
            inputSchema: {
                type: 'ZodObject',
                shape: {
                    stringKeyRecord: {
                        type: 'ZodRecord',
                        keyType: { type: 'ZodString' },
                        valueType: { type: 'ZodNumber' },
                        description: 'A record field with string keys'
                    },
                    numberKeyRecord: {
                        type: 'ZodRecord',
                        keyType: { type: 'ZodString' }, // Changed to ZodString
                        valueType: { type: 'ZodString' },
                        description: 'A record field with string keys (representing numbers)'
                    }
                }
            },
            outputSchema: { type: 'ZodAny' }
        };
        const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(httpToolOutput);
        const schemaShape = vercelAITool.parameters._def.shape();
        expect(schemaShape.stringKeyRecord).toBeInstanceOf(zod_1.z.ZodRecord);
        expect(schemaShape.numberKeyRecord).toBeInstanceOf(zod_1.z.ZodRecord);
        const validInput = {
            stringKeyRecord: { key1: 1, key2: 2 },
            numberKeyRecord: { '1': 'one', '2': 'two' }
        };
        const invalidInput = {
            stringKeyRecord: { key1: 'string' },
            numberKeyRecord: { key: 'invalid' }
        };
        const validResult = vercelAITool.parameters.safeParse(validInput);
        console.log('Valid input parse result:', validResult);
        const invalidResult = vercelAITool.parameters.safeParse(invalidInput);
        console.log('Invalid input parse result:', invalidResult);
        expect(validResult.success).toBe(true);
        expect(invalidResult.success).toBe(false);
    });
    it('should handle complex nested structures', () => {
        const complexHttpToolOutput = {
            id: 'complex-nested-tool',
            name: 'Complex Nested Tool',
            description: 'A tool with deeply nested structures',
            inputSchema: {
                type: 'ZodObject',
                shape: {
                    nestedUnions: {
                        type: 'ZodObject',
                        shape: {
                            unionField: {
                                type: 'ZodUnion',
                                options: [
                                    { type: 'ZodString' },
                                    {
                                        type: 'ZodObject',
                                        shape: {
                                            nestedEnum: {
                                                type: 'ZodEnum',
                                                values: ['option1', 'option2']
                                            }
                                        }
                                    }
                                ]
                            }
                        }
                    },
                    arrayOfUnions: {
                        type: 'ZodArray',
                        element: {
                            type: 'ZodUnion',
                            options: [
                                { type: 'ZodNumber' },
                                { type: 'ZodBoolean' }
                            ]
                        }
                    }
                }
            },
            outputSchema: { type: 'ZodAny' }
        };
        const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(complexHttpToolOutput);
        const schemaShape = vercelAITool.parameters._def.shape();
        expect(schemaShape.nestedUnions).toBeInstanceOf(zod_1.z.ZodObject);
        expect(schemaShape.nestedUnions._def.shape().unionField).toBeInstanceOf(zod_1.z.ZodUnion);
        expect(schemaShape.arrayOfUnions).toBeInstanceOf(zod_1.z.ZodArray);
        expect(schemaShape.arrayOfUnions._def.type).toBeInstanceOf(zod_1.z.ZodUnion);
        const validInput = {
            nestedUnions: {
                unionField: { nestedEnum: 'option1' }
            },
            arrayOfUnions: [1, true, 2, false]
        };
        const invalidInput = {
            nestedUnions: {
                unionField: { nestedEnum: 'invalid' }
            },
            arrayOfUnions: [1, 'string', true]
        };
        expect(vercelAITool.parameters.safeParse(validInput).success).toBe(true);
        expect(vercelAITool.parameters.safeParse(invalidInput).success).toBe(false);
    });
    it('should handle ZodLiteral and ZodTuple', () => {
        const httpToolOutput = {
            id: 'literal-tuple-tool',
            name: 'Literal and Tuple Tool',
            description: 'A tool with literal and tuple fields',
            inputSchema: {
                type: 'ZodObject',
                shape: {
                    literalField: {
                        type: 'ZodLiteral',
                        value: 'specific-value'
                    },
                    tupleField: {
                        type: 'ZodTuple',
                        items: [
                            { type: 'ZodString' },
                            { type: 'ZodNumber' },
                            { type: 'ZodBoolean' }
                        ]
                    }
                }
            },
            outputSchema: { type: 'ZodAny' }
        };
        const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(httpToolOutput);
        const schemaShape = vercelAITool.parameters._def.shape();
        expect(schemaShape.literalField).toBeInstanceOf(zod_1.z.ZodLiteral);
        expect(schemaShape.tupleField).toBeInstanceOf(zod_1.z.ZodTuple);
        const validInput = {
            literalField: 'specific-value',
            tupleField: ['string', 42, true]
        };
        const invalidInput = {
            literalField: 'wrong-value',
            tupleField: ['string', 42, 'not-boolean']
        };
        expect(vercelAITool.parameters.safeParse(validInput).success).toBe(true);
        expect(vercelAITool.parameters.safeParse(invalidInput).success).toBe(false);
    });
    it('should handle ZodIntersection and ZodDiscriminatedUnion', () => {
        const httpToolOutput = {
            id: 'intersection-discriminated-union-tool',
            name: 'Intersection and Discriminated Union Tool',
            description: 'A tool with intersection and discriminated union fields',
            inputSchema: {
                type: 'ZodObject',
                shape: {
                    intersectionField: {
                        type: 'ZodIntersection',
                        left: {
                            type: 'ZodObject',
                            shape: {
                                sharedField: { type: 'ZodString' }
                            }
                        },
                        right: {
                            type: 'ZodObject',
                            shape: {
                                uniqueField: { type: 'ZodNumber' }
                            }
                        }
                    },
                    discriminatedUnionField: {
                        type: 'ZodDiscriminatedUnion',
                        discriminator: 'type',
                        options: [
                            {
                                type: 'ZodObject',
                                shape: {
                                    type: { type: 'ZodLiteral', value: 'a' },
                                    a: { type: 'ZodString' }
                                }
                            },
                            {
                                type: 'ZodObject',
                                shape: {
                                    type: { type: 'ZodLiteral', value: 'b' },
                                    b: { type: 'ZodNumber' }
                                }
                            }
                        ]
                    }
                }
            },
            outputSchema: { type: 'ZodAny' }
        };
        const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(httpToolOutput);
        const schemaShape = vercelAITool.parameters._def.shape();
        expect(schemaShape.intersectionField).toBeInstanceOf(zod_1.z.ZodIntersection);
        expect(schemaShape.discriminatedUnionField).toBeInstanceOf(zod_1.z.ZodDiscriminatedUnion);
        const validInput = {
            intersectionField: {
                sharedField: 'shared',
                uniqueField: 42
            },
            discriminatedUnionField: {
                type: 'a',
                a: 'string value'
            }
        };
        const invalidInput = {
            intersectionField: {
                sharedField: 'shared',
                uniqueField: 'not a number'
            },
            discriminatedUnionField: {
                type: 'c',
                c: 'invalid'
            }
        };
        expect(vercelAITool.parameters.safeParse(validInput).success).toBe(true);
        expect(vercelAITool.parameters.safeParse(invalidInput).success).toBe(false);
    });
    it('should handle ZodRecord and nested arrays with objects', () => {
        const httpToolOutput = {
            id: 'record-nested-array-tool',
            name: 'Record and Nested Array Tool',
            description: 'A tool with record and nested array fields',
            inputSchema: {
                type: 'ZodObject',
                shape: {
                    recordField: {
                        type: 'ZodRecord',
                        keyType: { type: 'ZodString' },
                        valueType: { type: 'ZodNumber' },
                        description: 'A record field'
                    },
                    nestedArrayField: {
                        type: 'ZodArray',
                        element: {
                            type: 'ZodObject',
                            shape: {
                                name: { type: 'ZodString' },
                                value: { type: 'ZodNumber' }
                            }
                        },
                        description: 'A nested array field with objects'
                    }
                }
            },
            outputSchema: { type: 'ZodAny' }
        };
        const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(httpToolOutput);
        const schemaShape = vercelAITool.parameters._def.shape();
        expect(schemaShape.recordField).toBeInstanceOf(zod_1.z.ZodRecord);
        expect(schemaShape.nestedArrayField).toBeInstanceOf(zod_1.z.ZodArray);
        const validInput = {
            recordField: { key1: 1, key2: 2 },
            nestedArrayField: [
                { name: 'item1', value: 10 },
                { name: 'item2', value: 20 }
            ]
        };
        const invalidInput = {
            recordField: { key1: 'not a number' },
            nestedArrayField: [
                { name: 'item1', value: 'not a number' },
                { invalidKey: 'invalid' }
            ]
        };
        const validResult = vercelAITool.parameters.safeParse(validInput);
        const invalidResult = vercelAITool.parameters.safeParse(invalidInput);
        expect(validResult.success).toBe(true);
        expect(invalidResult.success).toBe(false);
    });
    it('should handle deeply nested structures with records and arrays', () => {
        const httpToolOutput = {
            id: 'deep-nested-tool',
            name: 'Deep Nested Tool',
            description: 'A tool with deeply nested structures including records and arrays',
            inputSchema: {
                type: 'ZodObject',
                shape: {
                    deeplyNested: {
                        type: 'ZodObject',
                        shape: {
                            recordOfArrays: {
                                type: 'ZodRecord',
                                keyType: { type: 'ZodString' },
                                valueType: {
                                    type: 'ZodArray',
                                    element: {
                                        type: 'ZodObject',
                                        shape: {
                                            id: { type: 'ZodNumber' },
                                            name: { type: 'ZodString' }
                                        }
                                    }
                                }
                            },
                            arrayOfRecords: {
                                type: 'ZodArray',
                                element: {
                                    type: 'ZodRecord',
                                    keyType: { type: 'ZodString' },
                                    valueType: { type: 'ZodUnion', options: [
                                            { type: 'ZodString' },
                                            { type: 'ZodNumber' }
                                        ] }
                                }
                            }
                        }
                    }
                }
            },
            outputSchema: { type: 'ZodAny' }
        };
        const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(httpToolOutput);
        const schemaShape = vercelAITool.parameters._def.shape();
        expect(schemaShape.deeplyNested).toBeInstanceOf(zod_1.z.ZodObject);
        expect(schemaShape.deeplyNested._def.shape().recordOfArrays).toBeInstanceOf(zod_1.z.ZodRecord);
        expect(schemaShape.deeplyNested._def.shape().arrayOfRecords).toBeInstanceOf(zod_1.z.ZodArray);
        const validInput = {
            deeplyNested: {
                recordOfArrays: {
                    key1: [{ id: 1, name: 'Item 1' }, { id: 2, name: 'Item 2' }],
                    key2: [{ id: 3, name: 'Item 3' }]
                },
                arrayOfRecords: [
                    { field1: 'string', field2: 42 },
                    { field3: 'another string', field4: 100 }
                ]
            }
        };
        const invalidInput = {
            deeplyNested: {
                recordOfArrays: {
                    key1: [{ id: 'not a number', name: 'Item 1' }]
                },
                arrayOfRecords: [
                    { field1: true, field2: 42 }
                ]
            }
        };
        const validResult = vercelAITool.parameters.safeParse(validInput);
        const invalidResult = vercelAITool.parameters.safeParse(invalidInput);
        expect(validResult.success).toBe(true);
        expect(invalidResult.success).toBe(false);
    });
});
//# sourceMappingURL=convertToVercelTool.test.js.map