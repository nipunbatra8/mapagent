"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createOrderOptionsSchema = exports.SMSOptionsSchema = exports.SMSMessageSetSchema = exports.emailReceiptSpecificationsSchema = exports.dropoffWindowSchema = exports.addedFeesSchema = exports.miscFeeSchema = exports.searchStoreOptionsSchema = exports.searchProductOptionsSchema = exports.MealMeIdSchema = void 0;
const zod_1 = require("zod");
const schemaStructure_1 = require("../lib/schemaStructure");
const convertToVercelTool_1 = require("../lib/convertToVercelTool");
exports.MealMeIdSchema = zod_1.z.string();
exports.searchProductOptionsSchema = zod_1.z.object({
    query: zod_1.z
        .string()
        .optional()
        .describe("The product / menu item / dish to search for (ex. Hamburger, lasagna or pad thai). If empty, this endpoint will let you browse products available for ordering nearby."),
    product_id: exports.MealMeIdSchema.optional().describe("Optional. If supplied, query will be ignored, and this endpoint will search for all matching products close to the user's location within the maximum_miles radius. A matching product is one that perfectly matches the same brand (i.e., Safeway) and product (i.e., Almond Breeze Unsweetened Original Almondmilk). Note: product_id can be retrieved from Get Inventory, Search For A Product, and Search For A Cart."),
    store_name: zod_1.z
        .string()
        .optional()
        .describe("The store from which to search for products within."),
    store_type: zod_1.z
        .string()
        .optional()
        .describe("The type of stores to search from. Can be grocery, restaurant, or an empty string for both."),
    menu_id: exports.MealMeIdSchema.optional().describe("The ID of the menu from which to search for products within. The menu ID is provided by Get Inventory."),
    user_latitude: zod_1.z
        .number()
        .default(37.7786357)
        .describe("The latitude of the user. Defaults to 37.7786357"),
    user_longitude: zod_1.z
        .number()
        .default(-122.3918135)
        .describe("The longitude of the user. In the US, this value is negative. Defaults to -122.3918135"),
    pickup: zod_1.z
        .boolean()
        .optional()
        .default(false)
        .describe("If true, filter stores to only those that offer pickup. If false, filter to only stores with delivery. Defaults to false"),
    budget: zod_1.z
        .number()
        .optional()
        .default(20)
        .describe("The maximum amount, in Dollars, that the user has specified they'd like to spend on an order. Required for applying a cheapest sort. Defaults to 20"),
    upc_codes: zod_1.z
        .string()
        .optional()
        .describe("The UPC codes to search for, delimited by comma. Takes precedence over the other ways you can search, query, and product_id."),
    cuisine: zod_1.z.string().optional().describe("The cuisine to filter products by."),
    user_street_num: zod_1.z
        .union([zod_1.z.string(), zod_1.z.number()])
        .transform((val) => val.toString())
        .optional()
        .default("188")
        .describe("Street number of the user. Required if fetch_quotes is true and pickup is false. Defaults to 188"),
    user_street_name: zod_1.z
        .string()
        .optional()
        .default("King Street")
        .describe("Street name of the user. Required if fetch_quotes is true and pickup is false. Defaults to King Street"),
    user_city: zod_1.z
        .string()
        .optional()
        .default("San Francisco")
        .describe("City of the user. Required if fetch_quotes is true and pickup is false. Defaults to San Francisco"),
    user_state: zod_1.z
        .string()
        .optional()
        .default("CA")
        .describe("State abbreviation of the user. Required if fetch_quotes is true and pickup is false. Defaults to CA"),
    user_zipcode: zod_1.z
        .union([zod_1.z.string(), zod_1.z.number()])
        .transform((val) => val.toString())
        .optional()
        .default("94107")
        .describe("Zipcode of the user. Required if fetch_quotes is true and pickup is false. Defaults to 94107"),
    user_country: zod_1.z
        .string()
        .optional()
        .default("US")
        .describe("Country of the user. Can be US or CA. Required if fetch_quotes is true and pickup is false. Defaults to US"),
    fetch_quotes: zod_1.z
        .boolean()
        .optional()
        .default(false)
        .describe("Whether to fetch real-time delivery/pickup quotes. Note that this being true greatly increases response time. Note that if this is true and the query is also empty, then store hours will not be in the response. Defaults to false"),
    sort: zod_1.z
        .string()
        .optional()
        .default("relevance")
        .describe("The sort type. Can be cheapest, fastest, rating, distance, or the default relevance. Defaults to relevance"),
    fuzzy_search: zod_1.z
        .boolean()
        .optional()
        .default(false)
        .describe("Whether to perform a lenient search that returns relevant products that may not exactly match the query provided. Defaults to false"),
    open: zod_1.z
        .boolean()
        .optional()
        .default(false)
        .describe("Whether to return only open restaurants. Defaults to false"),
    maximum_miles: zod_1.z
        .number()
        .optional()
        .default(1.5)
        .describe("The maximum distance allowed, in miles. Defaults to 1.5"),
    min_lat: zod_1.z
        .number()
        .optional()
        .describe("The minimum latitude for a 'Search In This Area'."),
    max_lat: zod_1.z
        .number()
        .optional()
        .describe("The maximum latitude for a 'Search In This Area'."),
    min_lon: zod_1.z
        .number()
        .optional()
        .describe("The minimum longitude for a 'Search In This Area'."),
    max_lon: zod_1.z
        .number()
        .optional()
        .describe("The maximum longitude for a 'Search In This Area'."),
    dollar_signs: zod_1.z
        .number()
        .optional()
        .describe("Cost for the average meal. This can represent 1 ($) for the cheapest stores or 4 ($$$$) for the most expensive stores."),
    minimum_rating: zod_1.z.number().optional().describe("The minimum rating allowed."),
    sale: zod_1.z
        .boolean()
        .optional()
        .default(false)
        .describe("Whether to search for products that are currently on sale. Defaults to false"),
    search_in_category: zod_1.z
        .string()
        .optional()
        .describe("The category of the menu to search for products within. The list of a menu's categories are provided by Get Inventory."),
    autocomplete: zod_1.z
        .boolean()
        .optional()
        .default(true)
        .describe("Whether to autocomplete the query. Defaults to true"),
    page: zod_1.z.number().optional().describe("The page to fetch."),
});
exports.searchStoreOptionsSchema = zod_1.z.object({
    query: zod_1.z
        .string()
        .optional()
        .describe("The search query. Try leaving this empty to browse what's available!"),
    latitude: zod_1.z
        .number()
        .default(37.7786357)
        .describe("The latitude of the user. Defaults to 37.7786357"),
    longitude: zod_1.z
        .number()
        .default(-122.3918135)
        .describe("The longitude of the user. In the US, this value is negative. Defaults to -122.3918135"),
    store_type: zod_1.z
        .union([zod_1.z.literal("restaurant"), zod_1.z.literal("grocery"), zod_1.z.literal("")])
        .optional()
        .describe("Defaults to restaurant"),
    budget: zod_1.z
        .number()
        .default(20)
        .describe("The maximum amount, in Dollars, that the user has specified they'd like to spend on this meal. Required for applying a sort. Defaults to 20"),
    user_street_num: zod_1.z
        .string()
        .optional()
        .describe("Street number of the user. Required if fetch_quotes is true and pickup is false. Defaults to King Street"),
    user_city: zod_1.z
        .string()
        .optional()
        .describe("City of the user. Required if fetch_quotes is true and pickup is false. Defaults to San Francisco"),
    user_state: zod_1.z
        .string()
        .optional()
        .describe("State abbreviation of the user. Required if fetch_quotes is true and pickup is false. Defaults to CA"),
    user_zipcode: zod_1.z
        .string()
        .optional()
        .describe("Zipcode of the user. Required if fetch_quotes is true and pickup is false. Defaults to 94107"),
    user_country: zod_1.z
        .enum(["US", "CA"])
        .optional()
        .describe("Country of the user. Can be US or CA. Required if fetch_quotes is true and pickup is false. Defaults to US"),
    pickup: zod_1.z
        .boolean()
        .default(false)
        .optional()
        .describe("If true, filter stores to only those that offer pickup. If false, filter to only stores with delivery. Defaults to false"),
    fetch_quotes: zod_1.z
        .boolean()
        .default(false)
        .optional()
        .describe("Whether to fetch realtime delivery/pickup quotes. Note that this being true greatly increases response time. Note that if this is true and the query is also empty then store hours will not be in the response. Defaults to false"),
    timeout: zod_1.z
        .number()
        .optional()
        .describe("Timeout to apply if fetch_quotes = true, in seconds."),
    sort: zod_1.z
        .string()
        .default("relevance")
        .optional()
        .describe("The sort type. Can be cheapest, fastest, rating, distance or the default relevance. Defaults to relevance"),
    open: zod_1.z
        .boolean()
        .default(false)
        .optional()
        .describe("Whether to return only open restaurants. Defaults to false"),
    dollar_signs: zod_1.z
        .number()
        .optional()
        .describe("Cost for the average meal. This can represent 1 ($) for the cheapest stores or 4 ($$$$) for the most expensive stores. Example: 2 (which would signal $$)."),
    cuisine: zod_1.z
        .string()
        .optional()
        .describe("The type of food (aka cuisine) to filter stores by. Example: Italian, Thai, Dim Sum, Sushi"),
    minimum_rating: zod_1.z
        .number()
        .optional()
        .describe("The minimum rating allowed. Example: 4.6."),
    maximum_miles: zod_1.z
        .number()
        .default(3)
        .optional()
        .describe("The maximum distance allowed, in miles. Defaults to 3. Example: 1.5."),
    page: zod_1.z
        .number()
        .optional()
        .describe("The page to fetch, to retrieve more results. This is returned as next_page in the response. Example: 0."),
    min_lat: zod_1.z
        .number()
        .optional()
        .describe('The minimum latitude for a "Search In This Area".'),
    max_lat: zod_1.z
        .number()
        .optional()
        .describe('The maximum latitude for a "Search In This Area".'),
    min_lon: zod_1.z
        .number()
        .optional()
        .describe('The minimum longitude for a "Search In This Area".'),
    max_lon: zod_1.z
        .number()
        .optional()
        .describe('The maximum longitude for a "Search In This Area".'),
    search_focus: zod_1.z
        .string()
        .default("store")
        .optional()
        .describe("Whether to focus the search on store name or item name. Can be item, store, or left empty for both. Defaults to store."),
    default_quote: zod_1.z
        .boolean()
        .default(false)
        .optional()
        .describe("Whether to return one default quote when fetch_quotes is true. Defaults to false."),
    autocomplete: zod_1.z
        .boolean()
        .default(false)
        .optional()
        .describe("Whether to autocomplete the query. Defaults to false."),
    include_utc_hours: zod_1.z
        .boolean()
        .default(false)
        .optional()
        .describe("Whether to include store hours in utc time. Defaults to false."),
    projections: zod_1.z
        .string()
        .optional()
        .describe("A comma-delimited list of store properties to include in the response, exclusively. Note that the following properties cannot be excluded: _id, name, address, type, is_open. If fetch_quotes is true, quotes cannot be excluded. Defaults to _id,name,address,type,is_open. Allowed values: _id, name, phone_number, address, description, hours, local_hours, cuisines, food_photos, logo_photos, store_photos, dollar_signs, pickup_enabled, delivery_enabled, is_open, offers_first_party_delivery, offers_third_party_delivery, miles, weighted_rating_value, aggregated_rating_count, supports_upc_codes, type"),
    use_new_db: zod_1.z
        .boolean()
        .default(true)
        .optional()
        .describe("Whether to perform the store search among a new database. Note that if use_new_db is true, use_new_db must also be true when making a request to Get Inventory or Get MealMe Store with any store _id returned from this request. Defaults to true."),
});
exports.miscFeeSchema = zod_1.z.object({
    fee_name: zod_1.z.string().describe("Name of the fee"),
    fee_amount: zod_1.z.number().describe("The fee amount, in cents"),
});
exports.addedFeesSchema = zod_1.z.object({
    added_fee_flat: zod_1.z
        .number()
        .optional()
        .describe("Flat fee added by API client, in cents. Defaults to 0"),
    added_fee_percent: zod_1.z
        .number()
        .optional()
        .describe("Percent fee added by API client, range [0-100]. Defaults to 0"),
    is_added_fee_taxable: zod_1.z
        .boolean()
        .optional()
        .describe("Whether API client added fee is taxable."),
});
exports.dropoffWindowSchema = zod_1.z.object({
    start_time: zod_1.z
        .number()
        .describe("The start of the drop-off window, represented by a unix timestamp."),
    end_time: zod_1.z
        .number()
        .describe("The end of the drop-off window, represented by a unix timestamp. Note that end_time must be at least 20 minutes greater than start_time."),
});
exports.emailReceiptSpecificationsSchema = zod_1.z.object({
    prices_marked: zod_1.z
        .boolean()
        .optional()
        .describe("If true, the price(s) in the email receipt will reflect the amount(s) specified via the product_marked_price and marked_price input parameters. Defaults to false"),
    added_fee: exports.addedFeesSchema
        .optional()
        .describe("Your added service fee. Any added fees will be reflected in the email receipt and included in the total charged when charge_user is true."),
    unify_service_fee: zod_1.z
        .boolean()
        .optional()
        .describe("Whether to combine the underlying service's service fee and your added_fee in one line item in the email receipt. Defaults to false"),
    misc_fees: zod_1.z
        .array(exports.miscFeeSchema)
        .describe("List of miscellaneous fees or discounts to display in the email receipt."),
    disable_email: zod_1.z
        .boolean()
        .describe("Whether to send the user an email receipt. Defaults to false"),
});
exports.SMSMessageSetSchema = zod_1.z.object({
    order_placed: zod_1.z
        .string()
        .optional()
        .describe("The SMS message to send to user_phone upon an order being successfully placed."),
    store_confirmed: zod_1.z
        .string()
        .optional()
        .describe("The SMS message to send to user_phone upon the store confirming the order."),
    pickup_ready: zod_1.z
        .string()
        .optional()
        .describe("The SMS message to send to user_phone when the store confirms the pickup order is ready."),
    driver_arriving: zod_1.z
        .string()
        .optional()
        .describe("The SMS message to send to user_phone when the driver is arriving to the delivery address."),
});
exports.SMSOptionsSchema = zod_1.z.object({
    notifications: exports.SMSMessageSetSchema.describe("The set of SMS messages for various order statuses."),
});
exports.createOrderOptionsSchema = zod_1.z.object({
    place_order: zod_1.z
        .boolean()
        .optional()
        .describe("Whether to actually place the order or just get the final quote. Defaults to false"),
    order_id: exports.MealMeIdSchema.optional().describe("The ID of an existing order to update."),
    // we will skip items as a parameter because we'll get it from the cart tool
    // items: z.array(orderItemSchema).describe("List of order items."),
    pickup: zod_1.z
        .boolean()
        .optional()
        .describe("Whether the order fulfillment type is pickup or delivery. Defaults to false"),
    scheduled_id: exports.MealMeIdSchema.optional().describe("The ID corresponding to the desired scheduled pickup/delivery window."),
    driver_tip_cents: zod_1.z
        .number()
        .optional()
        .describe("The tip for the driver, in cents. Defaults to 100"),
    pickup_tip_cents: zod_1.z
        .number()
        .optional()
        .describe("The tip for the store, in cents. Defaults to 0"),
    user_latitude: zod_1.z
        .number()
        .optional()
        .describe("Latitude of the user. Defaults to 37.7786357"),
    user_longitude: zod_1.z
        .number()
        .optional()
        .describe("Longitude of the user. Defaults to -122.3918135"),
    user_street_num: zod_1.z
        .union([zod_1.z.string(), zod_1.z.number()])
        .transform((val) => val.toString())
        .optional()
        .describe("Street number of the user. Defaults to 188"),
    user_street_name: zod_1.z
        .string()
        .optional()
        .describe("Street name of the user. Defaults to King Street"),
    user_apt_num: zod_1.z.string().optional().describe("Apartment number of the user."),
    user_city: zod_1.z
        .string()
        .optional()
        .describe("City of the user. Defaults to San Francisco"),
    user_state: zod_1.z
        .string()
        .optional()
        .describe("State of the user. Defaults to CA"),
    user_country: zod_1.z
        .string()
        .optional()
        .describe("Country of the user. Defaults to US"),
    user_zipcode: zod_1.z
        .union([zod_1.z.string(), zod_1.z.number()])
        .transform((val) => val.toString())
        .optional()
        .describe("Zipcode of the user. Defaults to 94107"),
    user_dropoff_notes: zod_1.z
        .string()
        .optional()
        .describe("Dropoff delivery notes for the user. Defaults to Leave in lobby"),
    user_pickup_notes: zod_1.z
        .string()
        .optional()
        .describe("User pickup notes for the store."),
    user_name: zod_1.z.string().describe("User's name. Defaults to Steve Jobs"),
    user_email: zod_1.z.string().describe("User's email. Defaults to steve@apple.com"),
    user_phone: zod_1.z
        .number()
        .describe("User's phone number. Defaults to 14044442058"),
    user_id: exports.MealMeIdSchema.describe("Unique User ID. Defaults to 7B36A9CF"),
    payment_method_id: exports.MealMeIdSchema.optional().describe("User's payment method ID."),
    charge_user: zod_1.z
        .boolean()
        .optional()
        .describe("Whether to charge the user. Defaults to true"),
    include_final_quote: zod_1.z
        .boolean()
        .optional()
        .describe("Whether to return the final quote. Defaults to true"),
    disable_sms: zod_1.z
        .boolean()
        .optional()
        .describe("Whether to send the user order status updates via SMS. Defaults to false"),
    email_receipt_specifications: exports.emailReceiptSpecificationsSchema
        .optional()
        .describe("Set of optional configurations used to modify email receipt"),
    sms_options: zod_1.z
        .array(exports.SMSOptionsSchema)
        .optional()
        .describe("Set of optional SMS-specific configurations."),
    favorited: zod_1.z
        .boolean()
        .optional()
        .describe("Whether to add this order as a favorited order. Defaults to false"),
    enable_substitution: zod_1.z
        .boolean()
        .optional()
        .describe("Whether to automatically substitute the cart with an equivalent one at a different nearby chain location. Defaults to false"),
    customer_order_id: exports.MealMeIdSchema.optional().describe("A unique ID of the order generated in your system."),
    autofill_selected_options: zod_1.z
        .boolean()
        .optional()
        .describe("Whether to automatically select the default quantity for all options and fulfill all customization requirements. Defaults to false"),
    metadata: zod_1.z
        .record(zod_1.z.string(), zod_1.z.string())
        .optional()
        .describe("A set of key-value pairs that you can attach to an order."),
    tracking_link: zod_1.z
        .string()
        .optional()
        .describe("The tracking link to communicate with the customer via SMS/email."),
    dropoff_window: exports.dropoffWindowSchema
        .optional()
        .describe("The desired delivery drop-off window."),
});
describe('searchProductOptionsSchema', () => {
    it('should validate a valid input', () => {
        const validInput = {
            query: "hamburger",
            user_latitude: 37.7786357,
            user_longitude: -122.3918135,
            pickup: true,
            budget: 30,
            maximum_miles: 2,
        };
        const result = exports.searchProductOptionsSchema.safeParse(validInput);
        expect(result.success).toBe(true);
    });
    it('should reject an invalid input', () => {
        const invalidInput = {
            query: 123, // Should be a string
            user_latitude: "invalid", // Should be a number
            pickup: "yes", // Should be a boolean
        };
        const result = exports.searchProductOptionsSchema.safeParse(invalidInput);
        expect(result.success).toBe(false);
    });
    it('should convert default values correctly', () => {
        const input = {
            user_latitude: 37.7786357,
            user_longitude: -122.3918135,
        };
        const result = exports.searchProductOptionsSchema.parse(input);
        expect(result.pickup).toBe(false);
        expect(result.budget).toBe(20);
        expect(result.maximum_miles).toBe(1.5);
        expect(result.user_street_num).toBe("188");
        expect(result.user_street_name).toBe("King Street");
        expect(result.user_city).toBe("San Francisco");
        expect(result.user_state).toBe("CA");
        expect(result.user_zipcode).toBe("94107");
        expect(result.user_country).toBe("US");
        expect(result.fetch_quotes).toBe(false);
        expect(result.sort).toBe("relevance");
        expect(result.fuzzy_search).toBe(false);
        expect(result.open).toBe(false);
        expect(result.sale).toBe(false);
        expect(result.autocomplete).toBe(true);
    });
    it('should convert to Vercel AI Tool format correctly', () => {
        const httpTool = {
            id: 'search-product-options',
            name: 'Search Product Options',
            description: 'Search for product options',
            inputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(exports.searchProductOptionsSchema),
            outputSchema: { type: 'ZodAny' }
        };
        const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(httpTool);
        expect(vercelAITool.name).toBe('search-product-options');
        expect(vercelAITool.description).toBe('Search for product options');
        expect(vercelAITool.parameters).toBeInstanceOf(zod_1.z.ZodObject);
        const schemaShape = vercelAITool.parameters._def.shape();
        expect(schemaShape.query).toBeInstanceOf(zod_1.z.ZodOptional);
    });
});
describe('searchStoreOptionsSchema', () => {
    it('should validate a valid input', () => {
        const validInput = {
            query: "pizza",
            latitude: 37.7786357,
            longitude: -122.3918135,
            store_type: "restaurant",
            budget: 30,
            pickup: true,
            maximum_miles: 2,
        };
        const result = exports.searchStoreOptionsSchema.safeParse(validInput);
        expect(result.success).toBe(true);
    });
    it('should reject an invalid input', () => {
        const invalidInput = {
            query: 123, // Should be a string
            latitude: "invalid", // Should be a number
            store_type: "invalid", // Should be "restaurant", "grocery", or ""
        };
        const result = exports.searchStoreOptionsSchema.safeParse(invalidInput);
        expect(result.success).toBe(false);
    });
    it('should convert default values correctly', () => {
        const input = {};
        const result = exports.searchStoreOptionsSchema.parse(input);
        expect(result.latitude).toBe(37.7786357);
        expect(result.longitude).toBe(-122.3918135);
        expect(result.budget).toBe(20);
    });
    it('should convert to Vercel AI Tool format correctly', () => {
        const httpTool = {
            id: 'search-product-options',
            name: 'Search Product Options',
            description: 'Search for product options',
            inputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(exports.searchProductOptionsSchema),
            outputSchema: { type: 'ZodAny' }
        };
        const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(httpTool);
        expect(vercelAITool.name).toBe('search-product-options');
        expect(vercelAITool.description).toBe('Search for product options');
        expect(vercelAITool.parameters).toBeInstanceOf(zod_1.z.ZodObject);
        const schemaShape = vercelAITool.parameters._def.shape();
        expect(schemaShape.query).toBeInstanceOf(zod_1.z.ZodOptional);
    });
});
describe('createOrderOptionsSchema', () => {
    it('should validate a valid input', () => {
        const validInput = {
            place_order: true,
            pickup: false,
            driver_tip_cents: 200,
            user_name: "John Doe",
            user_email: "john@example.com",
            user_phone: 1234567890,
            user_id: "USER123",
        };
        const result = exports.createOrderOptionsSchema.safeParse(validInput);
        expect(result.success).toBe(true);
    });
    it('should reject an invalid input', () => {
        const invalidInput = {
            place_order: "yes", // Should be a boolean
            user_name: 123, // Should be a string
            user_phone: "invalid", // Should be a number
        };
        const result = exports.createOrderOptionsSchema.safeParse(invalidInput);
        expect(result.success).toBe(false);
    });
    it('should handle optional fields correctly', () => {
        const input = {
            user_name: "John Doe",
            user_email: "john@example.com",
            user_phone: 1234567890,
            user_id: "USER123",
        };
        const result = exports.createOrderOptionsSchema.safeParse(input);
        expect(result.success).toBe(true);
    });
    it('should transform user_street_num and user_zipcode to string', () => {
        const input = {
            user_name: "John Doe",
            user_email: "john@example.com",
            user_phone: 1234567890,
            user_id: "USER123",
            user_street_num: 123,
            user_zipcode: 12345,
        };
        const result = exports.createOrderOptionsSchema.parse(input);
        expect(typeof result.user_street_num).toBe('string');
        expect(typeof result.user_zipcode).toBe('string');
    });
    it('should convert to Vercel AI Tool format correctly', () => {
        const httpTool = {
            id: 'create-order-options',
            name: 'Create Order Options',
            description: 'Create options for an order',
            inputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(exports.createOrderOptionsSchema),
            outputSchema: { type: 'ZodAny' }
        };
        const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(httpTool);
        expect(vercelAITool.name).toBe('create-order-options');
        expect(vercelAITool.description).toBe('Create options for an order');
        expect(vercelAITool.parameters).toBeInstanceOf(zod_1.z.ZodObject);
        const schemaShape = vercelAITool.parameters._def.shape();
        expect(schemaShape.place_order).toBeInstanceOf(zod_1.z.ZodOptional);
        expect(schemaShape.pickup).toBeInstanceOf(zod_1.z.ZodOptional);
        expect(schemaShape.driver_tip_cents).toBeInstanceOf(zod_1.z.ZodOptional);
        expect(schemaShape.user_name).toBeInstanceOf(zod_1.z.ZodString);
        expect(schemaShape.user_email).toBeInstanceOf(zod_1.z.ZodString);
        expect(schemaShape.user_phone).toBeInstanceOf(zod_1.z.ZodNumber);
        expect(schemaShape.user_id).toBeInstanceOf(zod_1.z.ZodString);
    });
});
//# sourceMappingURL=mealMeSchemas.test.js.map