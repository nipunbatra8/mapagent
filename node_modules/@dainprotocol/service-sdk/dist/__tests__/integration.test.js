"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
//File: src/___tests___/integration.test.ts
const nodeService_1 = require("../service/nodeService");
const core_1 = require("@/service/core");
const zod_1 = require("zod");
const supertest_1 = tslib_1.__importDefault(require("supertest"));
const ed25519_1 = require("@noble/curves/ed25519");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
const convertToVercelTool_1 = require("@/lib/convertToVercelTool");
const schemaStructure_1 = require("@/lib/schemaStructure");
const client_auth_1 = require("@/client/client-auth");
const client_1 = require("@/client/client");
describe("DAIN Framework Integration", () => {
    const privateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const publicKey = ed25519_1.ed25519.getPublicKey(privateKey);
    const address = bs58_1.default.encode(publicKey);
    const clientPrivateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const agentAuth = new client_auth_1.DainClientAuth({
        privateKeyBase58: bs58_1.default.encode(clientPrivateKey),
        agentId: "agent-12",
        orgId: "org-12",
    });
    // Initialize the connection to the DAIN service
    const dainConnection = new client_1.DainServiceConnection(
    //agent URI
    "http://localhost:3003", agentAuth);
    const weatherTool = (0, nodeService_1.createTool)({
        id: "get-weather",
        name: "Get Weather",
        description: "Fetches weather for a city",
        input: zod_1.z.object({ city: zod_1.z.string() }),
        output: zod_1.z.object({ temperature: zod_1.z.number(), condition: zod_1.z.string() }),
        pricing: { pricePerUse: 0.01, currency: "USD" },
        handler: async ({ city }, agentInfo, context) => {
            // Send loading state
            if (context.updateUI) {
                await context.updateUI({ ui: { type: "loading", message: "Fetching weather..." } });
            }
            // Add a delay to ensure events are spaced out
            await new Promise(resolve => setTimeout(resolve, 1000));
            // Create a process
            const processId = await context.app.processes.createProcess(agentInfo, "one-time", "Weather Update", `Getting weather for ${city}`);
            // Notify about process creation
            if (context.addProcess) {
                await context.addProcess(processId);
            }
            // Add another delay
            await new Promise(resolve => setTimeout(resolve, 1000));
            if (context.updateUI) {
                await context.updateUI({ ui: { type: "progress", message: "Processing data..." } });
            }
            // Final delay before result
            await new Promise(resolve => setTimeout(resolve, 1000));
            return {
                text: `The weather in ${city} is Sunny with a temperature of 22°C.`,
                data: { temperature: 22, condition: "Sunny" },
                ui: null,
            };
        },
    });
    const extraDataTool = (0, nodeService_1.createTool)({
        id: "extra-data-tool",
        name: "Extra Data Tool",
        description: "Tool to test extra data",
        input: zod_1.z.object({ cool: zod_1.z.string() }),
        output: zod_1.z.any(),
        pricing: { pricePerUse: 0.01, currency: "USD" },
        handler: async (cool, agentInfo, { extraData }) => {
            console.log("cool", cool);
            console.log("agentInfo", agentInfo);
            console.log("extraData", extraData);
            return {
                text: `Extra data: ${JSON.stringify(extraData)}`,
                data: { extraData },
                ui: null,
            };
        },
    });
    // Add a new tool with confirmation for testing
    const confirmationTool = (0, nodeService_1.createTool)({
        id: "confirmation-test-tool",
        name: "Confirmation Test Tool",
        description: "Tool that requires confirmation",
        input: zod_1.z.object({ action: zod_1.z.string() }),
        output: zod_1.z.object({ result: zod_1.z.string() }),
        suggestConfirmation: true,
        suggestConfirmationUI: async (input) => ({
            success: input.action !== "dangerous",
            ui: {
                type: "confirmation",
                title: "Confirm Action",
                message: `Are you sure you want to perform: ${input.action}?`,
                fields: [
                    {
                        type: "text",
                        label: "Additional Notes",
                        placeholder: "Add any notes here..."
                    }
                ]
            }
        }),
        handler: async ({ action }) => ({
            text: `Performed action: ${action}`,
            data: { result: `completed-${action}` },
            ui: null,
        }),
    });
    const weatherService = (0, nodeService_1.createService)({
        id: "weather-service",
        name: "Weather Service",
        description: "Provides weather information",
        metadata: {
            capabilities: ["current-weather"],
            languages: ["en"],
        },
        recommendedPrompt: "Ask about the weather",
        recommendedTools: ["get-weather", "extra-data-tool"],
    });
    const weatherToolbox = (0, nodeService_1.createToolbox)({
        id: "weather-toolbox",
        name: "Weather Toolbox",
        description: "Collection of weather tools",
        tools: ["get-weather", "extra-data-tool"],
        metadata: {
            complexity: "Low",
            applicableFields: ["Meteorology", "Travel"],
        },
        recommendedPrompt: "Use these tools for weather-related tasks",
    });
    const weatherContext = (0, core_1.createContext)({
        id: "weather-context",
        name: "Weather Context",
        description: "Context for weather data",
        getContextData: async () => {
            return "Weather data";
        },
    });
    const weatherPinnable = (0, core_1.createPinnable)({
        id: "weather-pinnable",
        type: "widget",
        label: "Weather Widget",
        name: "Weather Info",
        description: "Displays current weather information",
        icon: "☀️",
        getWidget: async () => ({
            text: "Current weather: Sunny, 22°C",
            data: { temperature: 22, condition: "Sunny" },
            ui: { type: "text" },
        }),
    });
    const dainService = (0, nodeService_1.defineDAINService)({
        metadata: {
            title: "Weather DAIN Service",
            description: "A DAIN service for weather information",
            version: "1.0.0",
            author: "Test Author",
            tags: ["weather", "dain"],
        },
        identity: {
            publicKey: bs58_1.default.encode(publicKey),
            agentId: "weather-agent",
            orgId: "weather-org",
            privateKey: bs58_1.default.encode(privateKey),
        },
        services: [weatherService],
        tools: [weatherTool, extraDataTool, confirmationTool],
        toolboxes: [weatherToolbox],
        contexts: [weatherContext],
        pinnables: [weatherPinnable],
    });
    let server;
    beforeAll(async () => {
        server = await dainService.startNode({ port: 3003 });
    });
    afterAll(async () => {
        await server.shutdown();
    });
    test("Service metadata is correct", () => {
        const metadata = dainService.getMetadata();
        expect(metadata.title).toBe("Weather DAIN Service");
        expect(metadata.tags).toContain("weather");
    });
    test("Service has correct tools and services", () => {
        expect(dainService.getTools()).toHaveLength(3);
        expect(dainService.getServices()).toHaveLength(1);
        expect(dainService.getToolboxes()).toHaveLength(1);
    });
    test("Can call weather tool with valid signature", async () => {
        const app = server.address();
        const port = app.port;
        const response = await dainConnection.makeRequest("POST", "/tools/get-weather", { city: "New York" });
        expect(response).toEqual({
            data: { temperature: 22, condition: "Sunny" },
            text: "The weather in New York is Sunny with a temperature of 22°C.",
            ui: null,
        });
    });
    test("Rejects call with invalid signature", async () => {
        const app = server.address();
        const port = app.port;
        const method = "POST";
        const path = "/tools/get-weather";
        const body = JSON.stringify({ city: "New York" });
        const headers = {
            "Content-Type": "application/json",
            "X-DAIN-Address": address,
        };
        const timestamp = new Date().toISOString();
        headers["X-DAIN-Timestamp"] = timestamp;
        const response = await (0, supertest_1.default)(`http://localhost:${port}`)
            .post("/tools/get-weather")
            .set("X-DAIN-Signature", "1231232113121")
            .set("X-DAIN-Address", address)
            .set("X-DAIN-Timestamp", timestamp)
            .send({ city: "New York" });
        expect(response.status).toBe(401);
    });
    describe("HTTP Output to Vercel AI Tool", () => {
        it("should convert a DAIN tool to HTTP output and then to Vercel AI tool format", () => {
            // Simulate a DAIN tool
            const dainTool = {
                id: "get-weather",
                name: "Get Weather",
                description: "Fetches weather for a city",
                pricing: { pricePerUse: 0.01, currency: "USD" },
                input: zod_1.z.object({
                    city: zod_1.z.string().describe("The name of the city"),
                    country: zod_1.z.string().optional().describe("The country of the city"),
                }),
                output: zod_1.z.object({
                    temperature: zod_1.z.number(),
                    condition: zod_1.z.string(),
                }),
                handler: async () => ({ temperature: 22, condition: "Sunny" }),
            };
            // Simulate the HTTP output
            const httpOutput = {
                id: dainTool.id,
                name: dainTool.name,
                description: dainTool.description,
                pricing: dainTool.pricing,
                inputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(dainTool.input),
                outputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(dainTool.output),
            };
            // Convert HTTP output to Vercel AI tool
            const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(httpOutput);
            // Assertions
            expect(vercelAITool.name).toBe("get-weather");
            expect(vercelAITool.description).toBe("Fetches weather for a city");
            expect(vercelAITool.parameters).toBeInstanceOf(zod_1.z.ZodObject);
            const params = vercelAITool.parameters.safeParse({
                city: "New York",
                country: "USA",
            });
            expect(params.success).toBe(true);
            // Use Zod's built-in methods to inspect the schema
            const schemaShape = vercelAITool.parameters._def.shape();
            expect(schemaShape.city.description).toBe("The name of the city");
            expect(schemaShape.country.description).toBe("The country of the city");
            // Test that the optional field is correctly preserved
            const paramsWithoutCountry = vercelAITool.parameters.safeParse({
                city: "Tokyo",
            });
            expect(paramsWithoutCountry.success).toBe(true);
            // Additional check for the optional nature of the country field
            expect(schemaShape.country instanceof zod_1.z.ZodOptional).toBe(true);
        });
    });
    it("Can List Contexts", async () => {
        const app = server.address();
        const port = app.port;
        const response = await dainConnection.makeRequest("GET", "/contexts", {});
        expect(response).toEqual([
            {
                id: "weather-context",
                name: "Weather Context",
                description: "Context for weather data",
            },
        ]);
    });
    it("Can call weather context with valid signature", async () => {
        const app = server.address();
        const port = app.port;
        const response = await dainConnection.makeRequest("GET", "/contexts/weather-context", {});
        expect(response).toEqual({
            id: "weather-context",
            name: "Weather Context",
            description: "Context for weather data",
            data: "Weather data",
        });
    });
    it("Can get all tools as json schema", async () => {
        const app = server.address();
        const port = app.port;
        const response = await dainConnection.makeRequest("GET", "/getAllToolsAsJsonSchema", {});
        console.log("JSON SCHEMA", JSON.stringify(response, null, 2));
        expect(response).toEqual({
            "tools": [
                {
                    "id": "get-weather",
                    "name": "Get Weather",
                    "description": "Fetches weather for a city",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "city": {
                                "type": "string"
                            }
                        },
                        "required": [
                            "city"
                        ],
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    },
                    "outputSchema": {
                        "type": "object",
                        "properties": {
                            "temperature": {
                                "type": "number"
                            },
                            "condition": {
                                "type": "string"
                            }
                        },
                        "required": [
                            "temperature",
                            "condition"
                        ],
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    }
                },
                {
                    "id": "extra-data-tool",
                    "name": "Extra Data Tool",
                    "description": "Tool to test extra data",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "cool": {
                                "type": "string"
                            }
                        },
                        "required": [
                            "cool"
                        ],
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    },
                    "outputSchema": {
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    }
                },
                {
                    "id": "confirmation-test-tool",
                    "name": "Confirmation Test Tool",
                    "description": "Tool that requires confirmation",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "action": {
                                "type": "string"
                            }
                        },
                        "required": [
                            "action"
                        ],
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    },
                    "outputSchema": {
                        "type": "object",
                        "properties": {
                            "result": {
                                "type": "string"
                            }
                        },
                        "required": [
                            "result"
                        ],
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    },
                    "suggestConfirmation": true
                }
            ],
            "reccomendedPrompts": [
                "Use these tools for weather-related tasks"
            ]
        });
    });
    describe("Pinnables", () => {
        it("Can list pinnables", async () => {
            const response = await dainConnection.getPinnables();
            expect(response).toHaveLength(1);
            expect(response[0]).toEqual({
                id: "weather-pinnable",
                type: "widget",
                label: "Weather Widget",
                name: "Weather Info",
                description: "Displays current weather information",
                icon: "☀️",
                size: "small",
            });
        });
        it("Can get a specific pinnable", async () => {
            const response = await dainConnection.getPinnable("weather-pinnable");
            expect(response).toEqual({
                id: "weather-pinnable",
                type: "widget",
                label: "Weather Widget",
                name: "Weather Info",
                description: "Displays current weather information",
                icon: "☀️",
                size: "small",
                widget: {
                    text: "Current weather: Sunny, 22°C",
                    data: { temperature: 22, condition: "Sunny" },
                    ui: { type: "text" },
                },
            });
        });
        // extra data tool
        it("Can call extra data tool", async () => {
            const response = await dainConnection.callTool("extra-data-tool", {
                cool: "cool",
                DAIN_EXTRA_DATA: {
                    testExtraData: "testExtraData",
                },
            });
            expect(response).toEqual({
                text: "Extra data: {\"testExtraData\":\"testExtraData\"}",
                data: { extraData: { testExtraData: "testExtraData" } },
                ui: null,
            });
        });
        it("Can get all pinnables with their widgets", async () => {
            const response = await dainConnection.getAllPinnables();
            expect(response).toHaveLength(1);
            expect(response[0]).toEqual({
                id: "weather-pinnable",
                type: "widget",
                label: "Weather Widget",
                size: "small",
                name: "Weather Info",
                description: "Displays current weather information",
                icon: "☀️",
                widget: {
                    text: "Current weather: Sunny, 22°C",
                    data: { temperature: 22, condition: "Sunny" },
                    ui: { type: "text" },
                },
            });
        });
        it("Rejects request for non-existent pinnable", async () => {
            await expect(dainConnection.getPinnable("non-existent-pinnable")).rejects.toThrow();
        });
    });
    // Add new test suite for confirmation functionality
    describe("Tool Confirmation", () => {
        it("Tool metadata includes confirmation settings", async () => {
            const tool = await dainConnection.getTool("confirmation-test-tool");
            expect(tool.suggestConfirmation).toBe(true);
        });
        it("Can get confirmation UI for a tool", async () => {
            const confirmation = await dainConnection.getToolConfirmation("confirmation-test-tool", {
                action: "test-action"
            });
            expect(confirmation).toEqual({
                success: true,
                ui: {
                    type: "confirmation",
                    title: "Confirm Action",
                    message: "Are you sure you want to perform: test-action?",
                    fields: [
                        {
                            type: "text",
                            label: "Additional Notes",
                            placeholder: "Add any notes here..."
                        }
                    ]
                }
            });
        });
        it("Returns success: false for dangerous actions", async () => {
            const confirmation = await dainConnection.getToolConfirmation("confirmation-test-tool", {
                action: "dangerous"
            });
            expect(confirmation.success).toBe(false);
        });
        it("Returns default success response for tools without confirmation UI", async () => {
            const confirmation = await dainConnection.getToolConfirmation("get-weather", {
                city: "London"
            });
            expect(confirmation).toEqual({
                success: true
            });
        });
        it("Rejects confirmation request for non-existent tool", async () => {
            await expect(dainConnection.getToolConfirmation("non-existent-tool", {})).rejects.toThrow();
        });
    });
    it("Can stream UI updates from weather tool", async () => {
        const uiUpdates = [];
        const result = await dainConnection.callTool("get-weather", { city: "London" }, {
            onUIUpdate: (update) => {
                uiUpdates.push(update.ui);
            }
        });
        // Verify UI updates were received
        expect(uiUpdates).toHaveLength(2);
        expect(uiUpdates[0]).toEqual({ type: "loading", message: "Fetching weather..." });
        expect(uiUpdates[1]).toEqual({ type: "progress", message: "Processing data..." });
        // Verify final result
        expect(result).toEqual({
            text: "The weather in London is Sunny with a temperature of 22°C.",
            data: { temperature: 22, condition: "Sunny" },
            ui: null,
        });
    });
    it("Maintains backwards compatibility with non-streaming clients", async () => {
        // Create a legacy client by removing the onUIUpdate option
        const result = await dainConnection.callTool("get-weather", {
            city: "London"
        });
        // Verify we get the final result without any streaming
        expect(result).toEqual({
            text: "The weather in London is Sunny with a temperature of 22°C.",
            data: { temperature: 22, condition: "Sunny" },
            ui: null,
        });
    });
    it("Maintains backwards compatibility for callToolAndGetNewContext", async () => {
        const result = await dainConnection.callToolAndGetNewContext("get-weather", {
            city: "London"
        });
        expect(result.toolResult).toEqual({
            text: "The weather in London is Sunny with a temperature of 22°C.",
            data: { temperature: 22, condition: "Sunny" },
            ui: null,
        });
        // Verify we still get context data
        expect(result.context).toBeDefined();
        expect(Array.isArray(result.context)).toBe(true);
        expect(result.context[0]).toHaveProperty('id', 'weather-context');
    });
    it("Can stream UI updates from weather tool with callToolAndGetNewContext", async () => {
        const uiUpdates = [];
        const result = await dainConnection.callToolAndGetNewContext("get-weather", { city: "Paris" }, {
            onUIUpdate: (update) => {
                uiUpdates.push(update.ui);
            }
        });
        // Verify UI updates were received
        expect(uiUpdates).toHaveLength(2);
        expect(uiUpdates[0]).toEqual({ type: "loading", message: "Fetching weather..." });
        expect(uiUpdates[1]).toEqual({ type: "progress", message: "Processing data..." });
        // Verify final result includes both tool result and context
        expect(result.toolResult).toEqual({
            text: "The weather in Paris is Sunny with a temperature of 22°C.",
            data: { temperature: 22, condition: "Sunny" },
            ui: null,
        });
        // Verify context data
        expect(result.context).toBeDefined();
        expect(Array.isArray(result.context)).toBe(true);
        expect(result.context[0]).toHaveProperty('id', 'weather-context');
    });
    it("Can stream process updates from weather tool", async () => {
        const uiUpdates = [];
        const processes = [];
        const result = await dainConnection.callTool("get-weather", { city: "London" }, {
            onUIUpdate: (update) => {
                uiUpdates.push(update.ui);
            },
            onProcess: (processId) => {
                processes.push(processId);
            }
        });
        // Verify process updates were received
        expect(processes).toHaveLength(1);
        expect(processes[0]).toMatch(/^service_.*_.*$/); // Check process ID format
        // Verify UI updates still work
        expect(uiUpdates).toHaveLength(2);
        // ... rest of the assertions ...
    });
    // Keep this test but modify it to be more explicit about timing
    it("Sends SSE events immediately rather than buffering", async () => {
        const events = [];
        let lastTimestamp = Date.now();
        const result = await dainConnection.callTool("get-weather", { city: "London" }, {
            onUIUpdate: () => {
                const now = Date.now();
                const delay = now - lastTimestamp;
                events.push({ type: 'ui', timestamp: now, delay });
                lastTimestamp = now;
                console.log('UI Update received at:', now, 'delay:', delay); // Add logging
            },
            onProcess: () => {
                const now = Date.now();
                const delay = now - lastTimestamp;
                events.push({ type: 'process', timestamp: now, delay });
                lastTimestamp = now;
                console.log('Process Update received at:', now, 'delay:', delay); // Add logging
            }
        });
        const now = Date.now();
        events.push({ type: 'result', timestamp: now, delay: now - lastTimestamp });
        console.log('Final result received at:', now); // Add logging
        // Verify we got all expected events
        expect(events).toHaveLength(4);
        // Log the events to see what's happening
        console.log('Events with delays:', events);
        // Check each event came after the previous one with reasonable delay
        events.slice(1).forEach(event => {
            expect(event.delay).toBeGreaterThan(30); // Each event should be at least 30ms after the previous
        });
    });
});
//# sourceMappingURL=integration.test.js.map