"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ed25519_1 = require("@noble/curves/ed25519");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
const nodeService_1 = require("../service/nodeService");
const zod_1 = require("zod");
const client_auth_1 = require("../client/client-auth");
const api_sdk_1 = require("../client/api-sdk");
const http_1 = require("http");
describe("Process Handler", () => {
    const privateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const publicKey = ed25519_1.ed25519.getPublicKey(privateKey);
    const clientPrivateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    // Store webhook calls
    let webhookCalls = [];
    let webhookServer;
    const WEBHOOK_PORT = 3099;
    const agentAuth = new client_auth_1.DainClientAuth({
        privateKeyBase58: bs58_1.default.encode(clientPrivateKey),
        agentId: "agent-12",
        orgId: "org-12",
        webhookUrl: `http://localhost:${WEBHOOK_PORT}/webhooks`
    });
    // Create a test tool that uses processes
    const longRunningTool = (0, nodeService_1.createTool)({
        id: "long-running-test",
        name: "long-running-test",
        description: "A test tool that creates a process",
        input: zod_1.z.object({
            duration: zod_1.z.number().describe("Duration in seconds"),
        }),
        output: zod_1.z.object({
            processId: zod_1.z.string(),
            status: zod_1.z.string()
        }),
        pricing: {
            pricePerUse: 0,
            currency: "USD"
        },
        handler: async ({ duration }, agentInfo, { app }) => {
            const processId = await app.processes.createProcess(agentInfo, "one-time", "Test Process", "A test long-running process");
            // Simulate a long-running process
            setTimeout(async () => {
                await app.processes.addUpdate(processId, {
                    percentage: 50,
                    text: "Halfway there..."
                });
                setTimeout(async () => {
                    await app.processes.addUpdate(processId, {
                        percentage: 100,
                        text: "Process complete!"
                    });
                    await app.processes.addResult(processId, {
                        text: "Process finished successfully",
                        data: { completed: true },
                        ui: { type: "success" }
                    });
                }, duration * 500);
            }, duration * 500);
            return {
                text: "Process started",
                data: { processId, status: "running" },
                ui: { type: "process-started", processId }
            };
        }
    });
    const failingTool = (0, nodeService_1.createTool)({
        id: "failing-process",
        name: "failing-process",
        description: "A test tool that creates a failing process",
        input: zod_1.z.object({}),
        output: zod_1.z.object({ processId: zod_1.z.string() }),
        pricing: {
            pricePerUse: 0,
            currency: "USD"
        },
        handler: async (_, agentInfo, { app }) => {
            const processId = await app.processes.createProcess(agentInfo, "one-time", "Failing Process", "A process that will fail");
            setTimeout(async () => {
                await app.processes.failProcess(processId, "Simulated failure");
            }, 500);
            return {
                text: "Process started",
                data: { processId },
                ui: { type: "process-started", processId }
            };
        }
    });
    const multiProcessTool = (0, nodeService_1.createTool)({
        id: "multi-process-test",
        name: "multi-process-test",
        description: "A tool that creates multiple processes",
        input: zod_1.z.object({}),
        output: zod_1.z.object({
            processIds: zod_1.z.array(zod_1.z.string())
        }),
        pricing: {
            pricePerUse: 0,
            currency: "USD"
        },
        handler: async (_, agentInfo, { app }) => {
            // Create two processes
            const process1Id = await app.processes.createProcess(agentInfo, "one-time", "First Process", "The first test process");
            const process2Id = await app.processes.createProcess(agentInfo, "one-time", "Second Process", "The second test process");
            return {
                text: "Started multiple processes",
                data: { processIds: [process1Id, process2Id] },
                ui: { type: "processes-started" },
                processes: [process1Id, process2Id]
            };
        }
    });
    // Create test service
    const dainService = (0, nodeService_1.defineDAINService)({
        metadata: {
            title: "Test Process Service",
            description: "A test DAIN service with process handling",
            version: "1.0.0",
            author: "Test Author",
            tags: ["test"],
        },
        identity: {
            publicKey: bs58_1.default.encode(publicKey),
            agentId: "test-agent",
            orgId: "test-org",
            privateKey: bs58_1.default.encode(privateKey),
        },
        tools: [longRunningTool, failingTool, multiProcessTool],
    });
    let server;
    let sdk;
    beforeAll(async () => {
        // Start webhook server
        webhookServer = (0, http_1.createServer)((req, res) => {
            let body = '';
            req.on('data', chunk => { body += chunk.toString(); });
            req.on('end', () => {
                webhookCalls.push({
                    headers: req.headers,
                    body: JSON.parse(body)
                });
                res.writeHead(200);
                res.end('OK');
            });
        });
        await new Promise(resolve => {
            webhookServer.listen(WEBHOOK_PORT, () => {
                console.log(`Webhook server listening on port ${WEBHOOK_PORT}`);
                resolve();
            });
        });
        // Start DAIN service
        server = await dainService.startNode({ port: 3018 });
        sdk = new api_sdk_1.DainSDK("http://localhost:3018", agentAuth);
        await sdk.initialize();
    });
    afterAll(async () => {
        // Cleanup servers
        if (server) {
            await server.shutdown();
        }
        if (webhookServer) {
            await new Promise(resolve => webhookServer.close(resolve));
        }
    });
    beforeEach(() => {
        webhookCalls = [];
    });
    describe("Process Creation and Updates", () => {
        it("should create a process and receive updates via webhook", async () => {
            // @ts-ignore - Accessing generated method
            const result = await sdk.longRunningTest({
                duration: 1
            });
            expect(result.data.processId).toBeDefined();
            expect(result.data.status).toBe("running");
            // Wait for process updates
            await new Promise(resolve => setTimeout(resolve, 2000));
            // Verify webhook calls
            expect(webhookCalls.length).toBe(4); // Should receive: created + 2 updates + result
            // Process created
            expect(webhookCalls[0].body.type).toBe("process_created");
            // First update (50%)
            expect(webhookCalls[1].body.type).toBe("process_update");
            expect(webhookCalls[1].body.update.percentage).toBe(50);
            expect(webhookCalls[1].body.update.text).toBe("Halfway there...");
            // Second update (100%)
            expect(webhookCalls[2].body.type).toBe("process_update");
            expect(webhookCalls[2].body.update.percentage).toBe(100);
            expect(webhookCalls[2].body.update.text).toBe("Process complete!");
            // Final result
            expect(webhookCalls[3].body.type).toBe("process_result");
            expect(webhookCalls[3].body.result.text).toBe("Process finished successfully");
            expect(webhookCalls[3].body.result.data.completed).toBe(true);
        });
        it("should handle process failures correctly", async () => {
            // @ts-ignore - Accessing generated method
            const result = await sdk.failingProcess({});
            // Wait for process failure
            await new Promise(resolve => setTimeout(resolve, 1000));
            // Verify failure webhook
            const failureCall = webhookCalls.find(call => call.body.type === "process_failed");
            expect(failureCall).toBeDefined();
            expect(failureCall.body.error).toBe("Simulated failure");
        });
    });
    describe("Process Verification", () => {
        it("should include valid signatures in webhook calls", () => {
            webhookCalls.forEach(call => {
                expect(call.headers["x-dain-signature"]).toBeDefined();
                expect(call.headers["x-dain-timestamp"]).toBeDefined();
                expect(call.headers["x-dain-process-id"]).toBeDefined();
            });
        });
    });
    describe("Multi-Process Handling", () => {
        it("should create multiple processes from a single tool call", async () => {
            // @ts-ignore - Accessing generated method
            const result = await sdk.multiProcessTest({});
            // Verify the response
            expect(result.data.processIds).toHaveLength(2);
            expect(result.processes).toHaveLength(2);
            // Wait for webhooks to be delivered
            await new Promise(resolve => setTimeout(resolve, 100));
            // Debug logs
            console.log('Webhook calls received:', webhookCalls.length);
            console.log('Process IDs in response:', result.data.processIds);
            console.log('Webhook process IDs:', webhookCalls.map(call => call.headers["x-dain-process-id"]));
            // Verify each process was created
            const webhookProcessIds = webhookCalls
                .filter(call => call.body.type === "process_created")
                .map(call => call.headers["x-dain-process-id"]);
            expect(webhookProcessIds).toContain(result.data.processIds[0]);
            expect(webhookProcessIds).toContain(result.data.processIds[1]);
        });
    });
});
//# sourceMappingURL=processes.test.js.map