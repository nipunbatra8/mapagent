"use strict";
// File: src/__tests__/auth.test.ts
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const client_auth_1 = require("@/client/client-auth");
const auth_1 = require("../service/auth");
const ed25519_1 = require("@noble/curves/ed25519");
const sha256_1 = require("@noble/hashes/sha256");
const utils_1 = require("@noble/hashes/utils");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
describe("Auth Module", () => {
    // Generate a key pair for testing
    const privateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const publicKey = ed25519_1.ed25519.getPublicKey(privateKey);
    // Convert public key to base58 (Solana address format)
    const address = bs58_1.default.encode(publicKey);
    const clientPrivateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const clientAddress = bs58_1.default.encode(ed25519_1.ed25519.getPublicKey(clientPrivateKey));
    const agentAuth = new client_auth_1.DainClientAuth({
        privateKeyBase58: bs58_1.default.encode(clientPrivateKey),
        agentId: "agent-12",
        orgId: "org-12",
    });
    test("verifySignature validates correct signatures", () => {
        const message = "Hello, World!";
        const messageHash = (0, sha256_1.sha256)(message);
        const signature = ed25519_1.ed25519.sign(messageHash, privateKey);
        expect((0, auth_1.verifySignature)((0, utils_1.bytesToHex)(signature), message, address)).toBe(true);
    });
    test("verifySignature rejects incorrect signatures", () => {
        const message = "Hello, World!";
        const incorrectMessage = "Hello, World?";
        const messageHash = (0, sha256_1.sha256)(message);
        const signature = ed25519_1.ed25519.sign(messageHash, privateKey);
        expect((0, auth_1.verifySignature)((0, utils_1.bytesToHex)(signature), incorrectMessage, address)).toBe(false);
    });
    test("isValidSolanaAddress correctly validates Solana addresses", () => {
        expect((0, auth_1.isValidSolanaAddress)(address)).toBe(true);
        expect((0, auth_1.isValidSolanaAddress)("invalid_address")).toBe(false);
    });
    test.only("createRequestSignature generates a valid signature", async () => {
        const method = "GET";
        const path = "/api/test";
        const headers = { "content-type": "application/json" };
        const body = "{}";
        const { signature, timestamp } = await agentAuth.signRequest(method, path, body);
        headers["X-DAIN-TIMESTAMP"] = timestamp;
        const verified = (0, auth_1.verifyRequestSignature)(signature, method, path, (0, auth_1.sanitizeHeaders)(headers), body, clientAddress, undefined);
        expect(verified).toBe(true);
    });
    test("verifyRequestSignature validates correct request signatures", async () => {
        const method = "POST";
        const path = "/api/test";
        const headers = { "content-type": "application/json" };
        const body = JSON.stringify({ key: "value" });
        const { signature, timestamp } = await agentAuth.signRequest(method, path, body);
        const validHeaders = { ...headers, "X-DAIN-TIMESTAMP": timestamp };
        expect((0, auth_1.verifyRequestSignature)(signature, method, path, validHeaders, body, clientAddress, undefined)).toBe(true);
    });
    test("verifyRequestSignature rejects incorrect request signatures", async () => {
        const method = "POST";
        const path = "/api/test";
        const headers = { "content-type": "application/json" };
        const body = JSON.stringify({ key: "value" });
        const { signature, timestamp } = await agentAuth.signRequest(method, path, body);
        const invalidHeaders = {
            ...headers,
            "X-DAIN-TIMESTAMP": (parseInt(timestamp) + 1).toString(),
        }; // Modifying timestamp
        expect((0, auth_1.verifyRequestSignature)(signature, method, path, invalidHeaders, body, clientAddress, undefined)).toBe(false);
    });
    describe("signResponse and verifyResponse", () => {
        it("should sign a response and verify it successfully", () => {
            const privateKey = ed25519_1.ed25519.utils.randomPrivateKey();
            const publicKey = ed25519_1.ed25519.getPublicKey(privateKey);
            const responseBody = JSON.stringify({ message: "Hello, World!" });
            const { signature, timestamp } = (0, auth_1.signResponse)(privateKey, responseBody);
            const isValid = (0, auth_1.verifyResponse)(publicKey, responseBody, signature, timestamp);
            expect(isValid).toBe(true);
        });
        it("should fail verification with tampered response body", () => {
            const privateKey = ed25519_1.ed25519.utils.randomPrivateKey();
            const publicKey = ed25519_1.ed25519.getPublicKey(privateKey);
            const responseBody = JSON.stringify({ message: "Hello, World!" });
            const { signature, timestamp } = (0, auth_1.signResponse)(privateKey, responseBody);
            const tamperedBody = JSON.stringify({ message: "Tampered message" });
            const isValid = (0, auth_1.verifyResponse)(publicKey, tamperedBody, signature, timestamp);
            expect(isValid).toBe(false);
        });
        it("should fail verification with incorrect public key", () => {
            const privateKey = ed25519_1.ed25519.utils.randomPrivateKey();
            const wrongPrivateKey = ed25519_1.ed25519.utils.randomPrivateKey();
            const wrongPublicKey = ed25519_1.ed25519.getPublicKey(wrongPrivateKey);
            const responseBody = JSON.stringify({ message: "Hello, World!" });
            const { signature, timestamp } = (0, auth_1.signResponse)(privateKey, responseBody);
            const isValid = (0, auth_1.verifyResponse)(wrongPublicKey, responseBody, signature, timestamp);
            expect(isValid).toBe(false);
        });
        it("should fail verification with tampered timestamp", () => {
            const privateKey = ed25519_1.ed25519.utils.randomPrivateKey();
            const publicKey = ed25519_1.ed25519.getPublicKey(privateKey);
            const responseBody = JSON.stringify({ message: "Hello, World!" });
            const { signature, timestamp } = (0, auth_1.signResponse)(privateKey, responseBody);
            const tamperedTimestamp = (parseInt(timestamp) + 1000).toString();
            const isValid = (0, auth_1.verifyResponse)(publicKey, responseBody, signature, tamperedTimestamp);
            expect(isValid).toBe(false);
        });
    });
});
//# sourceMappingURL=auth.test.js.map