"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DainSDK = void 0;
const client_1 = require("./client");
const convertToVercelTool_1 = require("../lib/convertToVercelTool");
class DainSDK {
    connection;
    toolsCache = new Map();
    metadata;
    oauthProvidersCache = new Map();
    constructor(baseUrl, auth) {
        this.connection = new client_1.DainServiceConnection(baseUrl, auth);
    }
    /**
     * Initializes the SDK by loading all tools and metadata.
     * This must be called before using any tool methods.
     * @throws {Error} If the connection fails or service is unavailable
     */
    async initialize() {
        // Load metadata and cache it
        this.metadata = await this.connection.getMetadata();
        // Cache all tools
        const tools = await this.connection.getTools();
        tools.forEach(tool => this.toolsCache.set(tool.id, tool));
        // Also cache OAuth providers
        const providers = await this.connection.getOAuth2Providers();
        providers.forEach(provider => this.oauthProvidersCache.set(provider.name, provider));
        // Dynamically add methods for each tool
        await this.generateToolMethods();
        return this;
    }
    /**
     * Returns comprehensive documentation for all available tools and services
     * @returns {Promise<string>} Markdown formatted documentation
     */
    async getDocumentation() {
        if (!this.metadata) {
            throw new Error('SDK not initialized. Call initialize() first.');
        }
        let docs = `# ${this.metadata.title} API Documentation\n\n`;
        docs += `${this.metadata.description}\n\n`;
        docs += `Version: ${this.metadata.version}\n`;
        docs += `Author: ${this.metadata.author}\n\n`;
        // Add service capabilities
        docs += `## Service Capabilities\n\n`;
        docs += `- ${this.metadata.tags.join('\n- ')}\n\n`;
        // Add OAuth section after metadata
        const providers = await this.getOAuthProviders();
        if (providers.length > 0) {
            docs += `## OAuth Requirements\n\n`;
            docs += `This service requires authentication with the following providers:\n\n`;
            for (const provider of providers) {
                docs += `### ${provider.name}\n`;
                if (provider.config.reason) {
                    docs += `**Reason:** ${provider.config.reason}\n`;
                }
                docs += `**Scopes Required:** ${provider.config.scopes.join(', ')}\n\n`;
            }
        }
        // Document all available tools
        docs += `## Available Tools\n\n`;
        for (const tool of this.toolsCache.values()) {
            docs += `### ${tool.name}\n\n`;
            docs += `**Method Name:** \`${this.sanitizeMethodName(tool.name)}\`\n\n`;
            docs += `${tool.description}\n\n`;
            // Document input schema
            docs += `**Input Schema:**\n\`\`\`typescript\ntype Input = ${this.jsonSchemaToTypeScript(tool.inputSchema)};\n\`\`\`\n\n`;
            // Document output schema
            docs += `**Output Schema:**\n\`\`\`typescript\ntype Output = ${this.jsonSchemaToTypeScript(tool.outputSchema)};\n\`\`\`\n\n`;
            // Add example usage
            docs += `**Example Usage:**\n\`\`\`typescript\nconst result = await sdk.${this.sanitizeMethodName(tool.name)}(${this.generateTypedExample(tool.inputSchema)});\n\n`;
            docs += `// Result type:\ntype Result = {\n`;
            docs += `  data: Output;\n`;
            docs += `  text: string;\n`;
            docs += `  ui: any;\n`;
            docs += `};\n\`\`\`\n\n`;
            // Add OAuth requirements for this tool
            const oauthReqs = await this.getToolOAuthRequirements(tool.id);
            if (oauthReqs.required) {
                docs += `**OAuth Requirements:**\n`;
                for (const provider of oauthReqs.providers) {
                    docs += `- ${provider.name}${provider.reason ? `: ${provider.reason}` : ''}\n`;
                }
                docs += '\n';
            }
            docs += `\`\`\`\n(Example Parameters are just placeholders for the type, they are not real values)\n\n`;
        }
        return docs;
    }
    /**
     * Returns the raw schema documentation for a specific tool
     * @param toolId The ID of the tool
     */
    async getToolSchema(toolId) {
        const tool = this.toolsCache.get(toolId);
        if (!tool) {
            throw new Error(`Tool ${toolId} not found`);
        }
        return {
            input: tool.inputSchema,
            output: tool.outputSchema,
            description: tool.description
        };
    }
    generateSchemaDocumentation(schema, indent = '  ') {
        let docs = '';
        if (!schema) {
            return 'any';
        }
        // Add description if it exists
        if (schema?.description) {
            docs += `${indent}// ${schema.description}\n`;
        }
        // Handle optional and default types first
        if (schema.type === 'ZodOptional' && schema._def?.innerType) {
            return this.generateSchemaDocumentation(schema._def.innerType, indent);
        }
        if (schema.type === 'ZodDefault' && schema._def?.innerType) {
            return this.generateSchemaDocumentation(schema._def.innerType, indent);
        }
        switch (schema.type) {
            case 'ZodObject':
                docs += `${indent}{\n`;
                for (const [key, value] of Object.entries(schema.shape)) {
                    const zodValue = value;
                    // Add field description if it exists
                    if (zodValue?.description) {
                        docs += `${indent}  // ${zodValue.description}\n`;
                    }
                    // Add optional/default value information
                    const isOptional = zodValue?._def?.typeName === 'ZodOptional';
                    const hasDefault = zodValue?._def?.defaultValue !== undefined;
                    if (isOptional || hasDefault) {
                        const optionalText = isOptional ? '(optional)' : '';
                        const defaultText = hasDefault ? `(default: ${JSON.stringify(zodValue._def.defaultValue())})` : '';
                        const annotations = [optionalText, defaultText].filter(Boolean).join(' ');
                        docs += `${indent}  // ${annotations}\n`;
                    }
                    // Get the base type for optional/default fields
                    const baseType = isOptional && zodValue._def?.innerType ? zodValue._def.innerType : zodValue;
                    docs += `${indent}  ${key}: ${this.generateSchemaDocumentation(baseType, indent + '  ')}\n`;
                }
                docs += `${indent}}`;
                break;
            case 'ZodString':
                docs += `string`;
                break;
            case 'ZodNumber':
                docs += `number`;
                break;
            case 'ZodBoolean':
                docs += `boolean`;
                break;
            case 'ZodArray':
                docs += `Array<${this.generateSchemaDocumentation(schema.element, indent)}>`;
                break;
            case 'ZodEnum':
                docs += `${schema.values.map((v) => `"${v}"`).join(' | ')}`;
                break;
            default:
                docs += `any`;
        }
        return docs;
    }
    generateExampleParams(schema, indent = '  ') {
        let example = '';
        // Handle case where schema is undefined/null
        if (!schema) {
            return '';
        }
        if (schema.type === 'ZodObject' && schema.shape) {
            for (const [key, value] of Object.entries(schema.shape)) {
                example += `${indent}${key}: `;
                const zodValue = value;
                switch (zodValue?.type) {
                    case 'ZodString':
                        example += `"example_string"`;
                        break;
                    case 'ZodNumber':
                        example += `123`;
                        break;
                    case 'ZodBoolean':
                        example += `true`;
                        break;
                    case 'ZodArray':
                        example += `[]`;
                        break;
                    case 'ZodEnum':
                        example += `"${value.values[0]}"`;
                        break;
                    default:
                        example += `{}`;
                }
                example += `,\n`;
            }
        }
        return example;
    }
    sanitizeMethodName(name) {
        // First, convert to camelCase
        const camelCase = name
            .toLowerCase()
            .replace(/[-_\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '')
            .replace(/[^a-zA-Z0-9]/g, '');
        // Ensure first character is lowercase
        return camelCase.charAt(0).toLowerCase() + camelCase.slice(1);
    }
    async generateToolMethods() {
        for (const [toolId, toolConfig] of this.toolsCache) {
            const methodName = this.sanitizeMethodName(toolConfig.name);
            this[methodName] = async (params) => {
                try {
                    // Check OAuth requirements before executing
                    const oauthReqs = await this.getToolOAuthRequirements(toolId);
                    if (oauthReqs.required) {
                        const missingConnections = oauthReqs.providers.filter(p => !p.connected);
                        if (missingConnections.length > 0) {
                            throw new Error(`Missing required OAuth connections for ${toolConfig.name}:\n` +
                                missingConnections.map(p => `- ${p.name}${p.reason ? ` (${p.reason})` : ''}`).join('\n'));
                        }
                    }
                    const tool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(toolConfig);
                    tool.parameters.parse(params);
                    const result = await this.connection.callTool(toolId, params);
                    tool.returnSchema.parse(result.data);
                    return result;
                }
                catch (error) {
                    if (error.message.includes('parameters')) {
                        throw new Error(`Invalid parameters for ${toolConfig.name}: ${error.message}`);
                    }
                    else {
                        throw new Error(`Error executing ${toolConfig.name}: ${error.message}`);
                    }
                }
            };
        }
    }
    /**
     * Returns the metadata about the connected service
     */
    getServiceInfo() {
        return this.metadata;
    }
    /**
     * Returns all available tool configurations
     */
    getAvailableTools() {
        return Array.from(this.toolsCache.values());
    }
    /**
     * Gets information about all available OAuth providers and their connection status
     * @returns List of OAuth providers with their connection status
     */
    async getOAuthProviders() {
        return await this.connection.getOAuth2Providers();
    }
    /**
     * Gets an authentication URL for connecting with a specific OAuth provider
     * @param provider The name of the OAuth provider
     * @returns URL to initiate OAuth flow
     */
    async getOAuthConnectUrl(provider) {
        return await this.connection.getOAuth2ConnectUrl(provider);
    }
    /**
     * Checks if a tool requires specific OAuth connections and returns requirements
     * @param toolId The ID of the tool to check
     * @returns Required OAuth connections and their status
     */
    async getToolOAuthRequirements(toolId) {
        const tool = this.toolsCache.get(toolId);
        if (!tool) {
            throw new Error(`Tool ${toolId} not found`);
        }
        const providers = await this.getOAuthProviders();
        const requiredProviders = providers.filter(p => 
        // Check if this tool is explicitly required by the provider
        p.config.requiredTools?.includes(toolId));
        return {
            required: requiredProviders.length > 0,
            providers: requiredProviders.map(p => ({
                name: p.name,
                reason: p.config.reason,
                connected: p.connected
            }))
        };
    }
    generateExampleFromJsonSchema(schema, indent = '  ') {
        let example = '';
        if (!schema || !schema.properties) {
            return '';
        }
        for (const [key, prop] of Object.entries(schema.properties)) {
            example += `${indent}${key}: `;
            switch (prop.type) {
                case 'string':
                    example += `"example_string"`;
                    break;
                case 'number':
                case 'integer':
                    example += `123`;
                    break;
                case 'boolean':
                    example += `true`;
                    break;
                case 'array':
                    example += `[]`;
                    break;
                case 'object':
                    example += `{}`;
                    break;
                default:
                    if (prop.enum && prop.enum.length > 0) {
                        example += `"${prop.enum[0]}"`;
                    }
                    else {
                        example += `{}`;
                    }
            }
            example += `,\n`;
        }
        return example;
    }
    jsonSchemaToTypeScript(schema, indent = '') {
        if (!schema)
            return 'any';
        // Handle schema that's already in TypeScript format
        if (typeof schema === 'string')
            return schema;
        switch (schema.type) {
            case 'object':
                if (!schema.properties)
                    return 'Record<string, any>';
                const properties = Object.entries(schema.properties).map(([key, prop]) => {
                    const description = prop.description ?
                        `${indent}  // ${prop.description}\n` : '';
                    const required = schema.required?.includes(key);
                    const optionalMark = required ? '' : '?';
                    return `${description}${indent}  ${key}${optionalMark}: ${this.jsonSchemaToTypeScript(prop, indent + '  ')}`;
                });
                return `{\n${properties.join(';\n')};\n${indent}}`;
            case 'array':
                return `${this.jsonSchemaToTypeScript(schema.items, indent)}[]`;
            case 'string':
                if (schema.enum) {
                    return schema.enum.map(v => `'${v}'`).join(' | ');
                }
                return 'string';
            case 'number':
            case 'integer':
                return 'number';
            case 'boolean':
                return 'boolean';
            case 'null':
                return 'null';
            default:
                return 'any';
        }
    }
    generateTypedExample(schema, indent = '') {
        if (!schema || schema.type !== 'object')
            return '{}';
        const lines = Object.entries(schema.properties || {}).map(([key, prop]) => {
            const value = this.getExampleValue(prop);
            return `${indent}  ${key}: ${value}`;
        });
        return `{\n${lines.join(',\n')}\n${indent}}`;
    }
    getExampleValue(prop) {
        const comment = prop.description ? ` // ${prop.description}` : '';
        switch (prop.type) {
            case 'string':
                return `"example"${comment}`;
            case 'number':
            case 'integer':
                return `123${comment}`;
            case 'boolean':
                return `true${comment}`;
            case 'array':
                return `[]${comment}`;
            case 'object':
                return `{}${comment}`;
            default:
                if (prop.enum && prop.enum.length > 0) {
                    return `"${prop.enum[0]}"${comment}`;
                }
                return `{}${comment}`;
        }
    }
}
exports.DainSDK = DainSDK;
// Example usage with type safety:
/*
const auth = new DainClientAuth({ apiKey: 'your_api_key_here' });
const sdk = await new DainSDK('https://api.example.com', auth).initialize();

// TypeScript now knows about all available methods and their types
const result = await sdk.getWeather({
  latitude: 40.7128,
  longitude: -74.0060
});
*/
//# sourceMappingURL=api-sdk.js.map