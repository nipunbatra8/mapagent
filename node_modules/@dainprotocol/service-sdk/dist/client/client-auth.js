"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DainClientAuth = void 0;
const tslib_1 = require("tslib");
//File: src/client/client-auth.ts
const ed25519_1 = require("@noble/curves/ed25519");
const sha256_1 = require("@noble/hashes/sha256");
const utils_1 = require("@noble/hashes/utils");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
class DainClientAuth {
    privateKey;
    agentId;
    orgId;
    publicKey;
    smartAccountPDA;
    webhookUrl;
    constructor(config) {
        if (config.apiKey) {
            const { privateKey, agentId, orgId, publicKey } = this.parseApiKey(config.apiKey);
            this.privateKey = privateKey;
            this.agentId = agentId;
            this.orgId = orgId;
            this.publicKey = publicKey;
            this.webhookUrl = config.webhookUrl;
        }
        else if (config.privateKeyBase58 && config.agentId && config.orgId) {
            this.privateKey = bs58_1.default.decode(config.privateKeyBase58);
            this.agentId = config.agentId.replace('agent_', '');
            this.orgId = config.orgId.replace('org_', '');
            this.publicKey = ed25519_1.ed25519.getPublicKey(this.privateKey);
            this.webhookUrl = config.webhookUrl;
        }
        else {
            throw new Error('Invalid configuration. Provide either an apiKey or privateKeyBase58, agentId, and orgId.');
        }
        this.smartAccountPDA = config.smartAccountPDA;
    }
    parseApiKey(apiKey) {
        const parts = apiKey.split('_');
        if (parts.length !== 5 || parts[0] !== 'sk' || parts[1] !== 'agent') {
            throw new Error('Invalid API key format');
        }
        const orgId = parts[2].replace('org_', '');
        const agentId = parts[3].replace('agent_', '');
        const privateKeyBase58 = parts[4];
        const privateKey = bs58_1.default.decode(privateKeyBase58).slice(0, 32);
        const publicKey = bs58_1.default.decode(privateKeyBase58).slice(32);
        return { privateKey, agentId, orgId, publicKey };
    }
    async signRequest(method, path, body) {
        const timestamp = Date.now().toString();
        const message = `${method}:${path}:${timestamp}:${body}`;
        //   console.log("signRequest:", { message, timestamp });
        const messageHash = (0, sha256_1.sha256)(message);
        const signature = ed25519_1.ed25519.sign(messageHash, this.privateKey);
        return { signature: (0, utils_1.bytesToHex)(signature), timestamp };
    }
    getHeaders(signature, timestamp) {
        return {
            "X-DAIN-SIGNATURE": signature,
            "X-DAIN-TIMESTAMP": timestamp,
            "X-DAIN-AGENT-ID": this.agentId,
            "X-DAIN-ORG-ID": this.orgId,
            "X-DAIN-ADDRESS": bs58_1.default.encode(this.publicKey),
            "X-DAIN-SMART-ACCOUNT-PDA": this.smartAccountPDA,
            "X-DAIN-WEBHOOK-URL": this.webhookUrl,
        };
    }
    signMessage(message) {
        const messageHash = (0, sha256_1.sha256)(message);
        const signature = ed25519_1.ed25519.sign(messageHash, this.privateKey);
        return (0, utils_1.bytesToHex)(signature);
    }
    static verifyMessage(message, signature, publicKey) {
        const messageHash = (0, sha256_1.sha256)(message);
        return ed25519_1.ed25519.verify(signature, messageHash, publicKey);
    }
    // Helper methods to get agentId, orgId, publicKey, etc.
    getAgentId() {
        return this.agentId;
    }
    getOrgId() {
        return this.orgId;
    }
    getPublicKey() {
        return this.publicKey;
    }
    getPublicKeyBase58() {
        return bs58_1.default.encode(this.publicKey);
    }
    getSmartAccountPDA() {
        return this.smartAccountPDA;
    }
    getWebhookUrl() {
        return this.webhookUrl;
    }
    serialize() {
        const data = {
            privateKey: Array.from(this.privateKey),
            agentId: this.agentId,
            orgId: this.orgId,
            publicKey: Array.from(this.publicKey),
            smartAccountPDA: this.smartAccountPDA,
            webhookUrl: this.webhookUrl
        };
        return bs58_1.default.encode(Buffer.from(JSON.stringify(data)));
    }
    static deserialize(serialized) {
        try {
            const data = JSON.parse(Buffer.from(bs58_1.default.decode(serialized)).toString());
            return new DainClientAuth({
                privateKeyBase58: bs58_1.default.encode(new Uint8Array(data.privateKey)),
                agentId: data.agentId,
                orgId: data.orgId,
                smartAccountPDA: data.smartAccountPDA,
                webhookUrl: data.webhookUrl
            });
        }
        catch (error) {
            throw new Error('Failed to deserialize DainClientAuth: ' + error.message);
        }
    }
}
exports.DainClientAuth = DainClientAuth;
//# sourceMappingURL=client-auth.js.map