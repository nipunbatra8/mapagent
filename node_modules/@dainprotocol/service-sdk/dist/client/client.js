"use strict";
// File: src/client/client.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.DainServiceConnection = void 0;
const tslib_1 = require("tslib");
const zod_1 = require("zod");
const ai_1 = require("ai");
const axios_1 = tslib_1.__importDefault(require("axios"));
const types_1 = require("./types");
class DainServiceConnection {
    baseUrl;
    clientAuth;
    constructor(baseUrl, clientAuth) {
        this.baseUrl = baseUrl;
        this.clientAuth = clientAuth;
    }
    async makeRequest(method, path, body = {}) {
        const fullPath = `${this.baseUrl}${path}`;
        const bodyString = JSON.stringify(body);
        const { signature, timestamp } = await this.clientAuth.signRequest(method, path, bodyString);
        const response = await (0, axios_1.default)({
            method,
            url: fullPath,
            data: method === "POST" ? body : undefined,
            headers: {
                "Content-Type": "application/json",
                //  "User-Agent": "DAIN-SERVICE-CLIENT/1.0.7",
                ...this.clientAuth.getHeaders(signature, timestamp),
            },
        });
        return response.data;
    }
    async getMetadata() {
        const data = await this.makeRequest("GET", "/metadata");
        return types_1.MetadataSchema.parse(data);
    }
    async getExampleQueries() {
        try {
            const data = await this.makeRequest("GET", "/exampleQueries");
            return types_1.ExampleQueriesSchema.parse(data);
        }
        catch (error) {
            if (error.response?.status === 404) {
                return [];
            }
            throw error;
        }
    }
    async getServices() {
        const data = await this.makeRequest("GET", "/services");
        return zod_1.z.array(types_1.ServiceConfigSchema).parse(data);
    }
    async getToolboxes() {
        const data = await this.makeRequest("GET", "/toolboxes");
        return zod_1.z.array(types_1.ToolboxConfigSchema).parse(data);
    }
    async getToolbox(toolboxId) {
        const data = await this.makeRequest("GET", `/toolboxes/${toolboxId}`);
        return types_1.ToolboxConfigSchema.parse(data);
    }
    async getTools() {
        const data = await this.makeRequest("GET", "/tools");
        return zod_1.z.array(types_1.ToolConfigSchema).parse(data);
    }
    async getTool(toolId) {
        const data = await this.makeRequest("GET", `/tools/${toolId}`);
        return types_1.ToolConfigSchema.parse(data);
    }
    async getContexts() {
        const data = await this.makeRequest("GET", "/contexts");
        return zod_1.z.array(types_1.ServiceContextSchema).parse(data);
    }
    async getContext(contextId) {
        const data = await this.makeRequest("GET", `/contexts/${contextId}`);
        return types_1.ServiceContextWithDataSchema.parse(data);
    }
    async getAllContexts() {
        const data = await this.makeRequest("GET", "/getAllContexts");
        return zod_1.z.array(types_1.ServiceContextWithDataSchema).parse(data);
    }
    async getPinnables() {
        const data = await this.makeRequest("GET", "/pinnables");
        return zod_1.z.array(types_1.ServicePinnableSchema).parse(data);
    }
    async getPinnable(pinnableId) {
        const data = await this.makeRequest("GET", `/pinnables/${pinnableId}`);
        return types_1.ServicePinnableWithWidgetSchema.parse(data);
    }
    async getAllPinnables() {
        const data = await this.makeRequest("GET", "/getAllPinnables");
        return zod_1.z.array(types_1.ServicePinnableWithWidgetSchema).parse(data);
    }
    async getAllToolsAsJsonSchema() {
        const data = await this.makeRequest("GET", "/getAllToolsAsJsonSchema");
        const returned = types_1.GetAllToolsAsJsonSchemaResponseSchema.parse(data);
        return {
            tools: returned.tools,
            reccomendedPrompts: returned.reccomendedPrompts,
        };
    }
    async loadToolbox(toolboxId, execute = true) {
        const toolbox = await this.getToolbox(toolboxId);
        const tools = {};
        for (const toolId of toolbox.tools) {
            const toolInfo = await this.getTool(toolId);
            tools[toolId] = execute
                ? this.createVercelAITool(toolInfo)
                : this.createVercelAIToolWithoutExecute(toolInfo);
        }
        return tools;
    }
    createVercelAITool(toolInfo) {
        return (0, ai_1.tool)({
            description: toolInfo.description,
            parameters: this.convertSchemaToZod(toolInfo.inputSchema),
            execute: async (params) => {
                return {
                    toolInfo: toolInfo,
                    serviceInfo: await this.getMetadata(),
                    result: await this.makeRequest("POST", `/tools/${toolInfo.id}`, params),
                };
            },
        });
    }
    async callTool(toolId, params, options) {
        if (options?.onUIUpdate || options?.onProcess) {
            try {
                // Try streaming first
                const { signature, timestamp } = await this.clientAuth.signRequest('POST', `/tools/${toolId}`, JSON.stringify(params));
                const response = await fetch(`${this.baseUrl}/tools/${toolId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'text/event-stream',
                        ...this.clientAuth.getHeaders(signature, timestamp),
                    },
                    body: JSON.stringify(params),
                });
                // If server doesn't support streaming, it will respond with regular JSON
                if (response.headers.get('content-type')?.includes('application/json')) {
                    return response.json();
                }
                const reader = response.body?.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                if (!reader)
                    throw new Error('No response body');
                while (true) {
                    const { done, value } = await reader.read();
                    if (done)
                        break;
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';
                    let currentEvent = null;
                    let currentData = null;
                    for (const line of lines) {
                        // Debug
                        console.log('SSE line:', line);
                        if (line.startsWith('event:')) {
                            currentEvent = line.slice(6).trim();
                        }
                        else if (line.startsWith('data:')) {
                            currentData = line.slice(5).trim();
                            if (currentEvent && currentData) {
                                const data = JSON.parse(currentData);
                                if (currentEvent === 'uipage-update') {
                                    options.onUIUpdate?.(data);
                                }
                                else if (currentEvent === 'process-created' && options.onProcess) {
                                    options.onProcess(data.processId);
                                }
                                else if (currentEvent === 'result') {
                                    return data;
                                }
                                currentEvent = null;
                                currentData = null;
                            }
                        }
                    }
                }
                throw new Error('Stream ended without result');
            }
            catch (error) {
                // If streaming fails, fall back to regular request
                console.warn('Streaming failed, falling back to regular request:', error);
                return this.makeRequest("POST", `/tools/${toolId}`, params);
            }
        }
        else {
            // Use regular JSON request for backwards compatibility
            return this.makeRequest("POST", `/tools/${toolId}`, params);
        }
    }
    async callToolAndGetNewContext(toolId, params, options) {
        if (options?.onUIUpdate || options?.onProcess) {
            // Use streaming for UI updates
            const { signature, timestamp } = await this.clientAuth.signRequest('POST', `/tools/${toolId}/executeAndGetNewContext`, JSON.stringify(params));
            const response = await fetch(`${this.baseUrl}/tools/${toolId}/executeAndGetNewContext`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'text/event-stream',
                    ...this.clientAuth.getHeaders(signature, timestamp),
                },
                body: JSON.stringify(params),
            });
            const reader = response.body?.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            if (!reader)
                throw new Error('No response body');
            while (true) {
                const { done, value } = await reader.read();
                if (done)
                    break;
                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop() || '';
                let currentEvent = null;
                let currentData = null;
                for (const line of lines) {
                    // Debug
                    console.log('SSE line:', line);
                    if (line.startsWith('event:')) {
                        currentEvent = line.slice(6).trim();
                    }
                    else if (line.startsWith('data:')) {
                        currentData = line.slice(5).trim();
                        if (currentEvent && currentData) {
                            const data = JSON.parse(currentData);
                            if (currentEvent === 'uipage-update') {
                                options.onUIUpdate?.(data);
                            }
                            else if (currentEvent === 'process-created' && options.onProcess) {
                                options.onProcess(data.processId);
                            }
                            else if (currentEvent === 'result') {
                                return data;
                            }
                            currentEvent = null;
                            currentData = null;
                        }
                    }
                }
            }
            throw new Error('Stream ended without result');
        }
        else {
            // Legacy non-streaming behavior
            const result = await this.makeRequest("POST", `/tools/${toolId}/executeAndGetNewContext`, params);
            return {
                toolResult: result.toolResult,
                context: result.context,
            };
        }
    }
    createVercelAIToolWithoutExecute(toolInfo) {
        return (0, ai_1.tool)({
            description: toolInfo.description,
            parameters: this.convertSchemaToZod(toolInfo.inputSchema),
        });
    }
    convertSchemaToZod(schema) {
        switch (schema.type) {
            case "ZodObject":
                const shape = {};
                for (const [key, value] of Object.entries(schema.shape)) {
                    shape[key] = this.convertSchemaToZod(value);
                }
                return zod_1.z.object(shape).describe(schema.description || "");
            case "ZodString":
                return zod_1.z.string().describe(schema.description || "");
            case "ZodNumber":
                return zod_1.z.number().describe(schema.description || "");
            case "ZodBoolean":
                return zod_1.z.boolean().describe(schema.description || "");
            case "ZodArray":
                return zod_1.z
                    .array(this.convertSchemaToZod(schema.element))
                    .describe(schema.description || "");
            case "ZodEnum":
                return zod_1.z.enum(schema.values).describe(schema.description || "");
            case "ZodUnion":
                return zod_1.z
                    .union(schema.options.map((option) => this.convertSchemaToZod(option)))
                    .describe(schema.description || "");
            case "ZodOptional":
                return zod_1.z
                    .optional(this.convertSchemaToZod(schema.innerType))
                    .describe(schema.description || "");
            case "ZodNullable":
                return zod_1.z
                    .nullable(this.convertSchemaToZod(schema.innerType))
                    .describe(schema.description || "");
            case "ZodRecord":
                return zod_1.z
                    .record(this.convertSchemaToZod(schema.keyType), this.convertSchemaToZod(schema.valueType))
                    .describe(schema.description || "");
            case "ZodDate":
                return zod_1.z.date().describe(schema.description || "");
            case "ZodBigInt":
                return zod_1.z.bigint().describe(schema.description || "");
            case "ZodTuple":
                return zod_1.z
                    .tuple(schema.items.map((item) => this.convertSchemaToZod(item)))
                    .describe(schema.description || "");
            case "ZodIntersection":
                return zod_1.z
                    .intersection(this.convertSchemaToZod(schema.left), this.convertSchemaToZod(schema.right))
                    .describe(schema.description || "");
            case "ZodLiteral":
                return zod_1.z.literal(schema.value).describe(schema.description || "");
            case "ZodPromise":
                return zod_1.z
                    .promise(this.convertSchemaToZod(schema.type))
                    .describe(schema.description || "");
            case "ZodSet":
                return zod_1.z
                    .set(this.convertSchemaToZod(schema.valueType))
                    .describe(schema.description || "");
            case "ZodMap":
                return zod_1.z
                    .map(this.convertSchemaToZod(schema.keyType), this.convertSchemaToZod(schema.valueType))
                    .describe(schema.description || "");
            default:
                return zod_1.z.any().describe(schema.description || "Unknown type");
        }
    }
    async getProcessStatus(processId) {
        try {
            const data = await this.makeRequest("GET", `/processes/${processId}/status`);
            // Convert createdAt strings to Date objects
            if (data.updates) {
                data.updates = data.updates.map((update) => ({
                    ...update,
                    createdAt: new Date(update.createdAt),
                }));
            }
            return data;
        }
        catch (error) {
            if (error.response?.status === 404) {
                return null;
            }
            if (error.response?.status === 403) {
                throw new Error("Unauthorized access to process");
            }
            throw error;
        }
    }
    async getOAuth2Providers() {
        const data = await this.makeRequest("GET", "/oauth2/providers");
        return zod_1.z.array(types_1.OAuth2ProviderInfoSchema).parse(data);
    }
    async getOAuth2ConnectUrl(provider) {
        const data = await this.makeRequest("GET", `/oauth2/connect/${provider}`);
        return zod_1.z.object({ authUrl: zod_1.z.string() }).parse(data).authUrl;
    }
    // Get all human actions for a process
    async getProcessHumanActions(processId) {
        return this.makeRequest("GET", `/processes/${processId}/human-actions`);
    }
    // Get specific human action
    async getHumanAction(processId, stepId) {
        return this.makeRequest("GET", `/processes/${processId}/human-actions/${stepId}`);
    }
    // Respond to human action
    async respondToHumanAction(processId, stepId, actionId, responseText, data) {
        return this.makeRequest("POST", `/processes/${processId}/human-actions/${stepId}/respond`, {
            actionId,
            responseText,
            data
        });
    }
    async getToolConfirmation(toolId, input) {
        const response = await this.makeRequest("POST", `/tools/${toolId}/confirmation`, input);
        return response;
    }
}
exports.DainServiceConnection = DainServiceConnection;
//# sourceMappingURL=client.js.map